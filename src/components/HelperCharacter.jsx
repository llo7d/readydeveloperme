/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 helper.glb --transform 
Files: helper.glb [41.96MB] > D:\Code\readydeveloperme\public\helper-transformed.glb [10.2MB] (76%)
*/

import React, { useEffect, useState, useRef, forwardRef } from 'react'
import { useGraph, useThree } from '@react-three/fiber'
import { useGLTF, useAnimations, Html } from '@react-three/drei'
import { SkeletonUtils } from 'three-stdlib'
import * as THREE from 'three'
import { useMediaQuery } from 'react-responsive'

// TypeScript declarations for global variables
/** @typedef {Object} HelperUIConfig
 * @property {Object} badge - Badge configuration
 * @property {Object} badge.position - Badge position values
 * @property {number} badge.position.x - Left/right position
 * @property {number} badge.position.y - Up/down position (height)
 * @property {number} badge.position.z - Forward/back position
 * @property {number} badge.scale - Scale when active
 * @property {Object} chatbox - Chatbox configuration
 * @property {Object} chatbox.position - Position values
 * @property {number} chatbox.position.x - Left/right position
 * @property {number} chatbox.position.y - Up/down position
 * @property {number} chatbox.position.z - Forward/back position
 * @property {number} chatbox.scale - Size scale
 * @property {number} chatbox.width - Width in pixels
 * @property {number} chatbox.height - Height in pixels
 * @property {Object} shadow - Shadow configuration
 * @property {Object} shadow.colors - Shadow color configuration
 * @property {string} shadow.colors.default - Default shadow color
 * @property {string} shadow.colors.near - Shadow color when near
 * @property {Object} shadow.opacity - Shadow opacity configuration
 * @property {number} shadow.opacity.default - Default opacity
 * @property {number} shadow.opacity.near - Opacity when near
 */

// Add global styles to ensure HTML overlays work properly
const styleElement = document.createElement('style');
styleElement.innerHTML = `
  .helper-badge-wrapper {
    pointer-events: auto !important;
    cursor: pointer;
    z-index: 1001 !important;
  }
  
  .helper-badge {
    cursor: pointer !important;
  }
  
  .helper-chatbox-wrapper {
    pointer-events: auto !important;
    z-index: 999 !important;
  }
`;
document.head.appendChild(styleElement);

// Create a global movement control state that can be accessed by the movement controller
window.chatboxOpen = false

// UI configuration for Helper Character with mobile-specific options
const helperUIConfig = {
  // Character position and size
  position: {
    desktop: [-5.6, 0, 15],  // [x, y, z] for desktop
    mobile: [-2.5, 0, 10]     // [x, y, z] for mobile (closer/more visible)
  },
  scale: {
    desktop: 0.14,          // Desktop scale
    mobile: 0.12            // Mobile scale (slightly smaller)
  },
  // Character box UI
  messageBox: {
    width: {
      desktop: 390,        // Desktop width in pixels
      mobile: 280          // Mobile width in pixels (smaller)
    },
    position: {
      desktop: { top: '60px', right: '60px', transform: 'none' },
      mobile: { top: '40px', right: '10px', transform: 'none' },
      center: { top: '50%', right: '50%', transform: 'translate(50%, -50%)' }
    },
    fontSize: {
      desktop: '14px',
      mobile: '12px'
    },
    zIndex: 1000,
  },
  // Badges for interactions
  badge: {
    size: {
      desktop: '11px',
      mobile: '10px'
    },
    position: {
      desktop: { x: 0, y: 17, z: 0 },
      mobile: { x: 0, y: 15, z: 0 }
    },
    scale: 1.1
  },
  // Shadow configuration
  shadow: {
    normalColor: '#2a2a2a',  // Dark color when not near
    nearColor: '#22aa22',    // Green when near (matching ClothingShop)
    normalOpacity: 0.7,
    nearOpacity: 0.5
  }
};

// Add console helpers for adjusting the UI
console.log("=== Helper UI Configuration Guide ===");
console.log("Access via the browser console:");
console.log("");
console.log("Position:");
console.log("window.helperUIConfig.position.mobile = [x, y, z]");
console.log("");
console.log("Scale:");
console.log("window.helperUIConfig.scale.mobile = 0.15");
console.log("");
console.log("Message Box Width:");
console.log("window.helperUIConfig.messageBox.width.mobile = 300");
console.log("");
console.log("Center Message Box:");
console.log("window.helperUIConfig.messageBox.position.desktop = window.helperUIConfig.messageBox.position.center");
console.log("window.helperUIConfig.messageBox.position.mobile = window.helperUIConfig.messageBox.position.center");
console.log("");
console.log("Shadow Color:");
console.log("window.helperUIConfig.shadow.nearColor = '#00AA00'");
console.log("================================");

// Make configuration accessible globally for real-time adjustments
if (typeof window !== 'undefined') {
  window.helperUIConfig = helperUIConfig;
}

const HelperCharacter = forwardRef((props, ref) => {
  const group = React.useRef()
  const [isNear, setIsNear] = useState(false)
  const [showChatbox, setShowChatbox] = useState(false)
  const [message, setMessage] = useState('')
  const [reply, setReply] = useState([])
  const chatContainerRef = useRef(null)
  const { scene, animations } = useGLTF('/AI_HELPER.glb')
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene])
  const { nodes, materials } = useGraph(clone)
  const { actions } = useAnimations(animations, group)
  const { camera } = useThree() // Access the camera

  // Add this line to detect mobile view
  const isMobile = useMediaQuery({ query: '(max-width: 768px)' });
  
  // For example, in your render function:
  // Use the appropriate scale based on device
  const scale = isMobile ? helperUIConfig.scale.mobile : helperUIConfig.scale.desktop;
  
  // Use the appropriate position based on device
  const position = isMobile ? helperUIConfig.position.mobile : helperUIConfig.position.desktop;
  
  // Later in your component
  // For the message box styling
  const messageBoxStyle = {
    width: isMobile ? helperUIConfig.messageBox.width.mobile : helperUIConfig.messageBox.width.desktop,
    fontSize: isMobile ? helperUIConfig.messageBox.fontSize.mobile : helperUIConfig.messageBox.fontSize.desktop,
    position: 'fixed',
    top: isMobile ? helperUIConfig.messageBox.position.mobile.top : helperUIConfig.messageBox.position.desktop.top,
    right: isMobile ? helperUIConfig.messageBox.position.mobile.right : helperUIConfig.messageBox.position.desktop.right,
    transform: isMobile ? helperUIConfig.messageBox.position.mobile.transform : helperUIConfig.messageBox.position.desktop.transform,
    zIndex: helperUIConfig.messageBox.zIndex,
    // ... other existing styles
  };
  
  // For the badge styling
  const badgeSize = isMobile ? helperUIConfig.badge.size.mobile : helperUIConfig.badge.size.desktop;
  const badgePosition = isMobile ? helperUIConfig.badge.position.mobile : helperUIConfig.badge.position.desktop;
  
  // Define a character shadow component
  const CharacterShadow = () => {
    return (
      <mesh 
        rotation={[-Math.PI / 2, 0, 0]} 
        position={[0, 0.01, 1]} 
        receiveShadow={false}
      >
        <circleGeometry args={[5, 64]} />
        <meshBasicMaterial 
          color={isNear ? helperUIConfig.shadow.nearColor : helperUIConfig.shadow.normalColor}
          transparent={true}
          opacity={isNear ? helperUIConfig.shadow.nearOpacity : helperUIConfig.shadow.normalOpacity}
          depthWrite={false}
        />
      </mesh>
    );
  };

  // Connect the forwarded ref to our group
  React.useImperativeHandle(ref, () => group.current)

  // Set up a state to track post-chat transition
  const [inPostChatTransition, setInPostChatTransition] = useState(false);

  // Store original rotation to return to after conversation ends
  const originalRotation = useRef([0, Math.PI / 4, 0]);
  
  // Create a ref for target rotation - moved outside useEffect
  const targetRotation = useRef(0);

  // Rotate helper to face camera when chatbox is opened
  useEffect(() => {
    if (!group.current) return;
    
    if (showChatbox) {
      // Save original rotation if not already saved
      if (!originalRotation.current) {
        originalRotation.current = [
          group.current.rotation.x,
          group.current.rotation.y,
          group.current.rotation.z
        ];
      }

      // Function to update target rotation based on camera position
      const updateTargetRotation = () => {
        if (!group.current || !camera) return;
        
        // Get positions
        const helperPos = new THREE.Vector3();
        group.current.getWorldPosition(helperPos);
        
        // Get camera position
        const cameraPos = new THREE.Vector3();
        camera.getWorldPosition(cameraPos);
        
        // Direction from helper to camera (only consider XZ plane)
        const direction = new THREE.Vector2(
          cameraPos.x - helperPos.x,
          cameraPos.z - helperPos.z
        );
        
        // Calculate target angle
        targetRotation.current = Math.atan2(direction.x, direction.y);
      };
      
      // Animation loop for smooth rotation
      const animateRotation = () => {
        if (!group.current) return;
        
        // Get current rotation and calculate the difference
        const currentRotation = group.current.rotation.y;
        let rotationDifference = targetRotation.current - currentRotation;
        
        // Handle rotation wrap-around (e.g., from 359° to 1°)
        if (rotationDifference > Math.PI) {
          rotationDifference -= Math.PI * 2;
        } else if (rotationDifference < -Math.PI) {
          rotationDifference += Math.PI * 2;
        }
        
        // Smoothly interpolate rotation
        if (Math.abs(rotationDifference) > 0.01) {
          group.current.rotation.y += rotationDifference * 0.1;
        }
      };
      
      // Update target rotation immediately and every 100ms
      updateTargetRotation();
      const targetUpdateInterval = setInterval(updateTargetRotation, 100);
      
      // Start animation loop using requestAnimationFrame for smooth rotation
      let animationFrameId;
      const animate = () => {
        animateRotation();
        animationFrameId = requestAnimationFrame(animate);
      };
      animate();
      
      // Clean up both the interval and animation frame
      return () => {
        clearInterval(targetUpdateInterval);
        cancelAnimationFrame(animationFrameId);
      };
    } else if (originalRotation.current) {
      // Smoothly return to original rotation when chat is closed
      const returnToOriginal = () => {
        if (!group.current) return;
        
        // Calculate difference between current and original rotation
        const currentRotation = group.current.rotation.y;
        const originalY = originalRotation.current[1];
        let rotationDifference = originalY - currentRotation;
        
        // Handle rotation wrap-around
        if (rotationDifference > Math.PI) {
          rotationDifference -= Math.PI * 2;
        } else if (rotationDifference < -Math.PI) {
          rotationDifference += Math.PI * 2;
        }
        
        // Smoothly transition back to original rotation
        if (Math.abs(rotationDifference) > 0.01) {
          group.current.rotation.y += rotationDifference * 0.1;
          requestAnimationFrame(returnToOriginal);
        } else {
          // Once we're close enough, set exact values
          group.current.rotation.x = originalRotation.current[0];
          group.current.rotation.y = originalRotation.current[1];
          group.current.rotation.z = originalRotation.current[2];
        }
      };
      
      // Start the return animation
      returnToOriginal();
    }
  }, [showChatbox, camera]);

  // Set global flag when chatbox state changes
  useEffect(() => {
    window.chatboxOpen = showChatbox;
    
    // If transitioning from open to closed, start transition period
    if (!showChatbox && !inPostChatTransition) {
      setInPostChatTransition(true);
      // Exit transition period after camera has had time to reposition
      setTimeout(() => {
        setInPostChatTransition(false);
      }, 1500); // 1.5 second transition time (increased from 1 second)
    }
    
    
    return () => {
      window.chatboxOpen = false;
    }
  }, [showChatbox, inPostChatTransition]);
  
  // Make the post-chat transition state available globally
  useEffect(() => {
    window.inChatTransition = inPostChatTransition;
  }, [inPostChatTransition]);

  // Set up the initial pose (Animation4) and animations
  useEffect(() => {
    if (!actions) return;
    
    // Log available animations for debugging
    console.log("Available animations:", Object.keys(actions));
    
    // Find Animation4 and Animation5
    const idleAnimation = actions['Animation4'] || Object.values(actions)[3]; // Fallback to 4th animation if not named
    const talkAnimation = actions['Animation5'] || Object.values(actions)[4]; // Fallback to 5th animation if not named
    
    // Set up animations with appropriate settings
    if (idleAnimation) {
      idleAnimation.reset();
      idleAnimation.setEffectiveTimeScale(1);
      idleAnimation.setLoop(THREE.LoopRepeat, Infinity);
      idleAnimation.clampWhenFinished = false;
      idleAnimation.play();
    }
    
    if (talkAnimation) {
      talkAnimation.reset();
      talkAnimation.setEffectiveTimeScale(1);
      talkAnimation.setLoop(THREE.LoopRepeat, Infinity);
      talkAnimation.clampWhenFinished = false;
      // Don't play it yet - we'll play it when needed
      talkAnimation.stop();
    }
    
    // Store animations in refs for later use
    window.helperAnimations = {
      idle: idleAnimation,
      talk: talkAnimation
    };
    
  }, [actions]);
  
  // Handle animations based on chatbox state and reply changes
  useEffect(() => {
    if (!window.helperAnimations?.idle || !window.helperAnimations?.talk) return;
    
    const { idle, talk } = window.helperAnimations;
    
    // Only trigger on chatbox close or open, not on every reply change
    // (The reply-based animation is now handled in handleSubmit)
    if (!showChatbox) {
      // When chatbox is closed, ensure we're in idle state
      
      // Stop any running animation transition
      if (window.animationTransitionTimeout) {
        clearTimeout(window.animationTransitionTimeout);
      }
      
      // Crossfade between animations
      talk.fadeOut(0.3);
      idle.reset();
      idle.fadeIn(0.3);
      idle.play();
    }
    
    // Cleanup
    return () => {
      if (window.animationTransitionTimeout) {
        clearTimeout(window.animationTransitionTimeout);
      }
    };
  }, [showChatbox]);

  // Simplified proximity detection without characterRef
  useEffect(() => {
    // Set a static value for isNear instead of checking proximity
    setIsNear(true);
    
    // For demonstration purposes, check if camera is near the helper
    if (camera) {
      const checkProximity = () => {
        if (!group.current) return;
        
        const helperPos = new THREE.Vector3();
        group.current.getWorldPosition(helperPos);
        
        const cameraPos = new THREE.Vector3();
        camera.getWorldPosition(cameraPos);
        
        const distance = cameraPos.distanceTo(helperPos);
        const newIsNear = distance < 15; // Larger radius for detection
        setIsNear(newIsNear);
        
        // If user walks away while chatbox is open, close it
        if (showChatbox && !newIsNear) {
          setShowChatbox(false);
          setMessage('');
          setReply([]);
        }
      };
      
      // Check proximity every 100ms
      const interval = setInterval(checkProximity, 100);
      return () => clearInterval(interval);
    }
  }, [camera, showChatbox]);
  
  // Set initial welcome message when chatbox opens
  useEffect(() => {
    if (showChatbox && reply.length === 0) {
      // Add welcome message when chatbox is opened for the first time
      setReply([
        { sender: 'ai', text: "Hi, I'm an AI assistant, how can I help?" }
      ])
    }
  }, [showChatbox, reply.length])
  
  // Auto-scroll to bottom when messages change
  useEffect(() => {
    if (chatContainerRef.current) {
      chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight
    }
  }, [reply])
  
  // Handle chat submission
  const handleSubmit = (e) => {
    e.preventDefault()
    if (message.trim()) {
      // Store user message and AI response
      const userMessage = message
      
      // Add user message immediately
      setReply(prev => [
        ...prev,
        { sender: 'user', text: userMessage }
      ])
      
      // Clear input field
      setMessage('')
      
      // Generate AI response based on user message
      let aiResponse = "Hi, I'm an AI assistant, how can I help?"
      
      // Simple response patterns for a more interactive feel
      const lowerMessage = userMessage.toLowerCase()
      if (lowerMessage.includes('hello') || lowerMessage.includes('hi')) {
        aiResponse = "Hello there! How can I assist you today?"
      } else if (lowerMessage.includes('how are you')) {
        aiResponse = "I'm doing well, thanks for asking! How can I help you?"
      } else if (lowerMessage.includes('help')) {
        aiResponse = "I'd be happy to help! What do you need assistance with?"
      } else if (lowerMessage.includes('thank')) {
        aiResponse = "You're welcome! Is there anything else you'd like to know?"
      } else if (lowerMessage.includes('bye') || lowerMessage.includes('goodbye')) {
        aiResponse = "Goodbye! Feel free to chat again if you need anything."
      }
      
      // Add AI response with a slight delay to simulate thinking
      setTimeout(() => {
        setReply(prev => [
          ...prev,
          { sender: 'ai', text: aiResponse }
        ])
        
        // Start talking animation - but first check if we have animations
        if (window.helperAnimations?.idle && window.helperAnimations?.talk) {
          const { idle, talk } = window.helperAnimations;
          
          console.log("Starting AI response animation");
          // Crossfade to talking animation
          idle.fadeOut(0.3);
          talk.reset();
          talk.fadeIn(0.3);
          talk.play();
          
          // Calculate duration based on message length
          // For better timing, count words rather than characters
          const wordCount = aiResponse.split(/\s+/).length;
          // Average speaking rate - approximately 2-3 words per second
          const speakingDuration = Math.max(2, Math.min(8, wordCount / 2.5));
          
          console.log(`AI response animation duration: ${speakingDuration}s (${wordCount} words)`);
          
          // After message "speaking" duration, transition back to idle
          if (window.animationTransitionTimeout) {
            clearTimeout(window.animationTransitionTimeout);
          }
          
          window.animationTransitionTimeout = setTimeout(() => {
            console.log("AI finished talking - returning to idle");
            talk.fadeOut(0.3);
            idle.reset();
            idle.fadeIn(0.3);
            idle.play();
          }, speakingDuration * 1000);
        }
      }, 500)
    }
  }

  // Function to safely close the chatbox
  const closeChatbox = () => {
    console.log("Closing chatbox from shared function");
    // First update state
    setShowChatbox(false);
    setMessage('');
    setReply([]);
    
    // Ensure the global flag is updated immediately
    window.chatboxOpen = false;
    
    // Force camera transition to complete by manipulating camera config temporarily
    if (window.cameraConfig) {
      // Store original values
      const originalDistance = window.cameraConfig.distance;
      const originalTransitionSpeed = window.cameraConfig.helperFocus.transitionSpeed;
      const originalReturnSpeed = window.cameraConfig.returnSpeed;
      
      // Temporarily boost transition speeds for immediate effect - but not too fast
      window.cameraConfig.helperFocus.transitionSpeed = 5; // Reduced from 10 for smoother transition
      window.cameraConfig.returnSpeed = 0.25; // Reduced from 0.5 for smoother transition
      
      // Temporarily increase distance for more zoom out, but not excessively
      window.cameraConfig.distance = 11.0; // Slightly less than before (was 12.0)
      
      // Restore original values after transition completes
      setTimeout(() => {
        // First step: reduce boosted values gradually
        window.cameraConfig.helperFocus.transitionSpeed = originalTransitionSpeed * 1.5;
        window.cameraConfig.returnSpeed = originalReturnSpeed * 1.5;
        window.cameraConfig.distance = originalDistance * 1.1;
        
        // Final step: restore original values completely
        setTimeout(() => {
          window.cameraConfig.helperFocus.transitionSpeed = originalTransitionSpeed;
          window.cameraConfig.returnSpeed = originalReturnSpeed;
          window.cameraConfig.distance = originalDistance;
        }, 500);
      }, 500);
    }
  }
  
  // Function to safely open the chatbox
  const openChatbox = () => {
    console.log("Opening chatbox from shared function");
    setShowChatbox(true);
    // Ensure the global flag is updated immediately
    window.chatboxOpen = true;
  }

  return (
    <group 
      ref={group} 
      dispose={null} 
      scale={scale} 
      position={position} 
      rotation={[0, Math.PI / 4, 0]}
    >
      {/* Character shadow */}
      <CharacterShadow />
      
      {/* Badge above character - only show when not in chat mode */}
      {!showChatbox && (
      <Html
          position={[
            isMobile ? helperUIConfig.badge.position.mobile.x : helperUIConfig.badge.position.desktop.x,
            isMobile ? helperUIConfig.badge.position.mobile.y : helperUIConfig.badge.position.desktop.y,
            isMobile ? helperUIConfig.badge.position.mobile.z : helperUIConfig.badge.position.desktop.z
          ]}
        center
          wrapperClass="helper-badge-wrapper"
          distanceFactor={15}
          onClick={(e) => {
            console.log("HTML Badge wrapper clicked");
            e.stopPropagation();
            if (isNear) {
              console.log("HTML Badge wrapper: Opening chatbox...");
              openChatbox();
            }
          }}
        >
          <button
            className="helper-badge"
            onClick={(e) => {
              e.stopPropagation();
              e.preventDefault();
              console.log("Button Badge clicked directly");
              
              if (isNear) {
                console.log("Badge Button: Opening chatbox...");
                openChatbox();
              }
            }}
        style={{
              background: isNear ? helperUIConfig.shadow.nearColor : helperUIConfig.shadow.normalColor,
              padding: '10px 16px',
              borderRadius: '10px',
              color: 'white',
              fontSize: '16px',
              fontWeight: '600',
              whiteSpace: 'nowrap',
              userSelect: 'none',
              fontFamily: 'system-ui, -apple-system, sans-serif',
              boxShadow: '0 3px 6px rgba(0,0,0,0.3)',
              border: '2px solid white',
              transition: 'all 0.3s ease',
              transform: isNear ? `scale(${helperUIConfig.badge.scale})` : 'scale(1)',
              cursor: isNear ? 'pointer' : 'default',
              pointerEvents: 'auto',
              zIndex: 1000,
              opacity: 0.9,
            }}
      >
        {isNear ? "Talk with me" : "AI Helper"}
          </button>
        </Html>
      )}
      
      {/* Stop talking button - only shown when in chat mode */}
      {showChatbox && (
        <Html
          position={[
            isMobile ? helperUIConfig.badge.position.mobile.x : helperUIConfig.badge.position.desktop.x,
            isMobile ? helperUIConfig.badge.position.mobile.y : helperUIConfig.badge.position.desktop.y,
            isMobile ? helperUIConfig.badge.position.mobile.z : helperUIConfig.badge.position.desktop.z
          ]}
          center
          wrapperClass="helper-badge-wrapper"
          distanceFactor={15}
        >
          <button
            className="helper-badge"
            onClick={(e) => {
              e.stopPropagation();
              console.log("Stop Talking button clicked");
              closeChatbox();
            }}
            style={{
              background: '#e74c3c',
              padding: '10px 16px',
              borderRadius: '10px',
              color: 'white',
              fontSize: '16px',
              fontWeight: '600',
              whiteSpace: 'nowrap',
              userSelect: 'none',
              fontFamily: 'system-ui, -apple-system, sans-serif',
              boxShadow: '0 3px 6px rgba(0,0,0,0.3)',
              border: '2px solid white',
              cursor: 'pointer',
              zIndex: 1010,
              opacity: 0.9,
            }}
          >
            Stop talking
          </button>
        </Html>
      )}
      
      {/* Chatbox popup */}
      {showChatbox && (
        <Html
          position={[0, 2, 0]}  // Use a simple, fixed position
          wrapperClass="helper-chatbox-wrapper"
          style={{
            width: messageBoxStyle.width,
            background: '#2a2a2a',
            borderRadius: '10px',
            boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
            padding: '16px',
            fontFamily: 'system-ui, -apple-system, sans-serif',
            pointerEvents: 'auto',
            color: 'white',
            zIndex: messageBoxStyle.zIndex,
            position: 'fixed',
            top: messageBoxStyle.top,
            right: messageBoxStyle.right,
            transform: messageBoxStyle.transform
          }}
        >
          <div style={{ position: 'relative' }} onClick={(e) => e.stopPropagation()}>
            <button
              onClick={(e) => {
                e.stopPropagation(); // Prevent event propagation
                console.log("X button: Closing chatbox...");
                closeChatbox();
              }}
              style={{
                position: 'absolute',
                top: '-5px',
                right: '-5px',
                background: '#e74c3c',
                color: 'white',
                border: 'none',
                borderRadius: '50%',
                width: '24px',
                height: '24px',
                cursor: 'pointer',
                fontSize: '14px',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                boxShadow: '0 2px 4px rgba(0,0,0,0.2)',
              }}
            >
              ✕
            </button>
            
            <div 
              ref={chatContainerRef}
              style={{ 
                height: isMobile ? '300px' : '400px',
                marginBottom: '10px', 
                padding: '10px',
                background: '#333',
                borderRadius: '8px',
                overflowY: 'auto',
                display: 'flex',
                flexDirection: 'column'
              }}
            >
              {reply.length > 0 ? (
                reply.map((msg, index) => (
                  <div 
                    key={index}
                    style={{ 
                      background: msg.sender === 'ai' ? '#37BA7E' : '#555',
                      padding: '8px 12px', 
                      borderRadius: '12px',
                      marginBottom: '8px',
                      marginLeft: msg.sender === 'ai' ? '0' : 'auto',
                      marginRight: msg.sender === 'ai' ? 'auto' : '0',
                      maxWidth: '80%',
                      color: 'white',
                      alignSelf: msg.sender === 'ai' ? 'flex-start' : 'flex-end',
                      textAlign: msg.sender === 'ai' ? 'left' : 'right',
                      wordBreak: 'break-word'
                    }}
                  >
                    {msg.text}
                  </div>
                ))
              ) : (
                <div style={{
                  textAlign: 'center',
                  color: '#888',
                  marginTop: 'auto',
                  marginBottom: 'auto',
                  fontSize: messageBoxStyle.fontSize
                }}>
                  Type a message to start chatting
                </div>
              )}
            </div>
            
            <form onSubmit={handleSubmit} style={{ display: 'flex' }}>
              <input
                type="text"
                value={message}
                onChange={(e) => setMessage(e.target.value)}
                placeholder="Type a message..."
                style={{
                  flex: 1,
                  padding: '8px 12px',
                  borderRadius: '20px',
                  border: '1px solid #444',
                  outline: 'none',
                  background: '#333',
                  color: 'white',
                }}
              />
              <button
                type="submit"
                style={{
                  background: '#37BA7E',
                  color: 'white',
                  border: 'none',
                  borderRadius: '20px',
                  padding: '8px 16px',
                  marginLeft: '8px',
                  cursor: 'pointer',
                  boxShadow: '0 2px 4px rgba(0,0,0,0.2)',
                }}
              >
                Send
              </button>
            </form>
          </div>
      </Html>
      )}
      
      {/* Character model */}
      <group name="Main" onClick={(e) => {
        console.log("Character model clicked, chatbox state:", showChatbox);
        if (isNear && !showChatbox) {
          // Only open the chatbox if it's not already open
          console.log("Character model: Opening chatbox...");
          openChatbox();
        }
      }}>
        {/* Invisible clickable area around character to make clicking easier */}
        <mesh 
          visible={false} 
          position={[0, 10, 0]}
          onClick={(e) => {
            console.log("Invisible click area triggered");
            e.stopPropagation();
            if (isNear && !showChatbox) {
              console.log("Invisible area: Opening chatbox...");
              openChatbox();
            }
          }}
        >
          <boxGeometry args={[15, 20, 15]} />
          <meshBasicMaterial transparent opacity={0} />
        </mesh>
        
        <group name="James_SoftwareEngineer_rig">
          <skinnedMesh
            name="Headphones"
            geometry={nodes.Headphones.geometry}
            material={materials.MAT_Headphone}
            skeleton={nodes.Headphones.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="James_5FingerHandArms001"
            geometry={nodes.James_5FingerHandArms001.geometry}
            material={materials.skin_Baked}
            skeleton={nodes.James_5FingerHandArms001.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="james_body_geo002"
            geometry={nodes.james_body_geo002.geometry}
            material={materials.skin_Baked}
            skeleton={nodes.james_body_geo002.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="james_cap001"
            geometry={nodes.james_cap001.geometry}
            material={materials.james_cap_Baked}
            skeleton={nodes.james_cap001.skeleton}
            castShadow
            receiveShadow
            material-color={isNear ? helperUIConfig.shadow.nearColor : helperUIConfig.shadow.normalColor}
          />
          <skinnedMesh
            name="james_facial_hair"
            geometry={nodes.james_facial_hair.geometry}
            material={materials['Facial hair']}
            skeleton={nodes.james_facial_hair.skeleton}
            castShadow
            receiveShadow
          />
          <group name="james_hair_geo002">
            <skinnedMesh
              name="james_hair_geo002_1"
              geometry={nodes.james_hair_geo002_1.geometry}
              material={materials.James_hairbase}
              skeleton={nodes.james_hair_geo002_1.skeleton}
              castShadow
              receiveShadow
            />
            <skinnedMesh
              name="james_hair_geo002_2"
              geometry={nodes.james_hair_geo002_2.geometry}
              material={materials.Hair}
              skeleton={nodes.james_hair_geo002_2.skeleton}
              castShadow
              receiveShadow
            />
          </group>
          <skinnedMesh
            name="james_lf_eye_geo001"
            geometry={nodes.james_lf_eye_geo001.geometry}
            material={materials['James_eyes.001']}
            skeleton={nodes.james_lf_eye_geo001.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="james_lowerteeth_geo001"
            geometry={nodes.james_lowerteeth_geo001.geometry}
            material={materials['James_Mouth.001']}
            skeleton={nodes.james_lowerteeth_geo001.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="james_pants_geo001"
            geometry={nodes.james_pants_geo001.geometry}
            material={materials['james_pants_geo.003_Baked']}
            skeleton={nodes.james_pants_geo001.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="james_rt_eyebrow_geo001"
            geometry={nodes.james_rt_eyebrow_geo001.geometry}
            material={materials.James_hairbase}
            skeleton={nodes.james_rt_eyebrow_geo001.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="james_shirt_geo"
            geometry={nodes.james_shirt_geo.geometry}
            material={materials['James_Shirt.001']}
            skeleton={nodes.james_shirt_geo.skeleton}
            castShadow
            receiveShadow
            material-color={isNear ? helperUIConfig.shadow.nearColor : helperUIConfig.shadow.normalColor}
          />
          <skinnedMesh
            name="james_Tongue"
            geometry={nodes.james_Tongue.geometry}
            material={materials['James_Mouth.001']}
            skeleton={nodes.james_Tongue.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="james_upperteeth_geo"
            geometry={nodes.james_upperteeth_geo.geometry}
            material={materials['James_Mouth.001']}
            skeleton={nodes.james_upperteeth_geo.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="james_vans_geo001"
            geometry={nodes.james_vans_geo001.geometry}
            material={materials.james_vans_geo_Baked}
            skeleton={nodes.james_vans_geo001.skeleton}
            castShadow
            receiveShadow
          />
          <primitive object={nodes.Bone} />
          <primitive object={nodes.HeadphoneRoot} />
          <primitive object={nodes.MacbookRoot} />
          <primitive object={nodes.rootx} />
          <primitive object={nodes.footl} />
          <primitive object={nodes.thigh_twistl} />
          <primitive object={nodes.footr} />
          <primitive object={nodes.thigh_twistr} />
          <primitive object={nodes.spine_01x} />
          <primitive object={nodes.spine_02x} />
          <primitive object={nodes.neckx} />
          <primitive object={nodes.shoulderr} />
          <primitive object={nodes.c_arm_twist_offsetr} />
          <primitive object={nodes.arm_stretchr} />
          <primitive object={nodes.shoulderl} />
          <primitive object={nodes.c_arm_twist_offsetl} />
          <primitive object={nodes.arm_stretchl} />
          <primitive object={nodes.spine_03x} />
          <primitive object={nodes.headx} />
          <primitive object={nodes.leg_stretchl} />
          <primitive object={nodes.leg_stretchr} />
          <primitive object={nodes.forearm_stretchl} />
          <primitive object={nodes.forearm_stretchr} />
          <primitive object={nodes.handl} />
          <primitive object={nodes.handr} />
        </group>
      </group>
    </group>
  )
})

export default HelperCharacter

useGLTF.preload('/AI_HELPER.glb')
