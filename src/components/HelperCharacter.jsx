/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 helper.glb --transform 
Files: helper.glb [41.96MB] > D:\Code\readydeveloperme\public\helper-transformed.glb [10.2MB] (76%)
*/

import React, { useEffect, useState, useRef, forwardRef } from 'react'
import { useGraph, useThree } from '@react-three/fiber'
import { useGLTF, useAnimations, Html } from '@react-three/drei'
import { SkeletonUtils } from 'three-stdlib'
import * as THREE from 'three'
import { useMediaQuery } from 'react-responsive'

// TypeScript declarations for global variables
/** @typedef {Object} HelperUIConfig
 * @property {Object} badge - Badge configuration
 * @property {Object} badge.position - Badge position values
 * @property {number} badge.position.x - Left/right position
 * @property {number} badge.position.y - Up/down position (height)
 * @property {number} badge.position.z - Forward/back position
 * @property {number} badge.scale - Scale when active
 * @property {Object} chatbox - Chatbox configuration
 * @property {Object} chatbox.position - Position values
 * @property {number} chatbox.position.x - Left/right position
 * @property {number} chatbox.position.y - Up/down position
 * @property {number} chatbox.position.z - Forward/back position
 * @property {number} chatbox.scale - Size scale
 * @property {number} chatbox.width - Width in pixels
 * @property {number} chatbox.height - Height in pixels
 * @property {Object} shadow - Shadow configuration
 * @property {Object} shadow.colors - Shadow color configuration
 * @property {string} shadow.colors.default - Default shadow color
 * @property {string} shadow.colors.near - Shadow color when near
 * @property {Object} shadow.opacity - Shadow opacity configuration
 * @property {number} shadow.opacity.default - Default opacity
 * @property {number} shadow.opacity.near - Opacity when near
 */

// Add global styles to ensure HTML overlays work properly
const styleElement = document.createElement('style');
styleElement.innerHTML = `
  .helper-badge-wrapper {
    pointer-events: auto !important;
    cursor: pointer;
    z-index: 1001 !important;
  }
  
  .helper-badge {
    cursor: pointer !important;
  }
  
  .helper-chatbox-wrapper {
    pointer-events: auto !important;
    z-index: 999 !important;
  }
  
  /* Custom scrollbar for Webkit browsers */
  .helper-chat-messages::-webkit-scrollbar {
    width: 6px;
  }
  
  .helper-chat-messages::-webkit-scrollbar-track {
    background: #333;
    border-radius: 4px;
  }
  
  .helper-chat-messages::-webkit-scrollbar-thumb {
    background: #555;
    border-radius: 4px;
  }
  
  .helper-chat-messages::-webkit-scrollbar-thumb:hover {
    background: #666;
  }
  
  /* Ensure input doesn't overflow on small screens */
  @media (max-width: 360px) {
    .helper-chat-form {
      flex-direction: column;
    }
    
    .helper-chat-input {
      margin-bottom: 8px;
    }
    
    .helper-chat-button {
      width: 100%;
      margin-left: 0 !important;
    }
  }
`;
document.head.appendChild(styleElement);

// Create a global movement control state that can be accessed by the movement controller
window.chatboxOpen = false
// Global flag to hide/show game messaging UI
window.hideGameMessaging = false
// Global flag to hide/show joystick
window.hideJoystick = false

// Game chat messaging UI configuration
const gameChatConfig = {
  // Main controls
  visible: true,     // Set to false to hide the chat UI completely
  opacity: 0.9,      // Default opacity
  
  // Positioning
  position: {
    desktop: { bottom: '20px', left: '50%' }, // Desktop position (CSS properties) - centered
    mobile: { bottom: '180px', left: '50%' }   // Mobile position (CSS properties) - centered
  },
  // Sizing
  size: {
    width: {
      desktop: 400,  // Width in pixels for desktop
      mobile: 'fullWidth'    // Mobile width is responsive by default
    },
    height: {
      desktop: 'auto', // Height for desktop
      mobile: 'auto'   // Height for mobile
    }
  }
};

// Create a direct control function to manage chat UI
if (typeof window !== 'undefined') {
  // Add global flag to force hide chat
  window.forceHideGameChat = false;
  
  // Function to force hide chat UI (with persistence)
  window.forceHideChatUI = (hide = true) => {
    // Set global flag
    window.forceHideGameChat = hide;
    
    // Set a cookie for persistence between reloads
    document.cookie = `forceHideGameChat=${hide ? 'true' : 'false'}; path=/; max-age=86400`;
    
    // Try to also update the DOM element directly for immediate effect
    try {
      const chatContainer = document.getElementById('game-chat-container');
      if (chatContainer) {
        chatContainer.style.display = hide ? 'none' : 'block';
        // console.log(`Directly ${hide ? 'hid' : 'showed'} chat container via DOM manipulation`);
      }
    } catch (err) {
      console.error('Error manipulating chat container:', err);
    }
    
    // Make sure game chat config is updated too
    if (window.gameChatConfig) {
      window.gameChatConfig.visible = !hide;
    }
    
    return hide;
  };
  
  // Expose the DOM direct manipulation function
  window.directlyHideChatUI = (hide = true) => {
    // First, update all the visibility flags
    window.hideGameMessaging = hide;
    
    if (window.gameChatConfig) {
      window.gameChatConfig.visible = !hide;
    }
    
    // Then directly manipulate the DOM for immediate effect
    const chatContainer = document.getElementById('game-chat-container');
    if (chatContainer) {
      chatContainer.style.display = hide ? 'none' : 'block';
      // console.log(`Directly ${hide ? 'hiding' : 'showing'} chat container via DOM manipulation`);
    } else {
      // console.log('Chat container element not found in DOM');
    }
  };
  
  // Check for the cookie on page load
  const checkChatVisibilityCookie = () => {
    const cookieValue = document.cookie
      .split('; ')
      .find(row => row.startsWith('forceHideGameChat='))
      ?.split('=')[1];
      
    if (cookieValue === 'true') {
      window.forceHideGameChat = true;
      setTimeout(() => {
        const chatContainer = document.getElementById('game-chat-container');
        if (chatContainer) {
          chatContainer.style.display = 'none';
          // console.log('Chat UI hidden based on saved preference');
        }
      }, 500); // Small delay to ensure DOM is ready
    }
  };
  
  // Call the function to check cookie
  checkChatVisibilityCookie();
  
  // Function to toggle chat visibility
  window.toggleChat = (visible) => {
    window.gameChatConfig.visible = visible;
    window.hideGameMessaging = !visible;
    
    // Direct DOM manipulation for immediate effect
    const chatContainer = document.getElementById('game-chat-container');
    if (chatContainer) {
      chatContainer.style.display = visible ? 'block' : 'none';
      // console.log(`Chat UI is now ${visible ? 'visible' : 'hidden'} (DOM updated directly)`);
    } else {
      // console.log(`Chat UI is now ${visible ? 'visible' : 'hidden'} (waiting for DOM update)`);
    }
  };

  // Function to position chat
  window.positionChat = (position, isMobile = false) => {
    // Example: {bottom: '100px', left: '50%'}
    if (isMobile) {
      window.gameChatConfig.position.mobile = position;
      // console.log('Mobile chat position updated:', position);
      
      // Direct DOM manipulation for immediate effect
      const chatContainer = document.getElementById('game-chat-container');
      if (chatContainer) {
        Object.keys(position).forEach(key => {
          chatContainer.style[key] = position[key];
        });
        
        // Ensure transform is applied for centering if left:50% is being used
        if (position.left === '50%') {
          chatContainer.style.transform = 'translateX(-50%)';
        }
      }
    } else {
      window.gameChatConfig.position.desktop = position;
      // console.log('Desktop chat position updated:', position);
      
      // Direct DOM manipulation for immediate effect
      const chatContainer = document.getElementById('game-chat-container');
      if (chatContainer) {
        Object.keys(position).forEach(key => {
          chatContainer.style[key] = position[key];
        });
        
        // Ensure transform is applied for centering if left:50% is being used
        if (position.left === '50%') {
          chatContainer.style.transform = 'translateX(-50%)';
        }
      }
    }
  };

  // Function to resize chat
  window.resizeChat = (width, isMobile = false) => {
    if (isMobile) {
      if (width === 'auto' || width === 'fullWidth') {
        // Calculate width as window width minus margins (20px on each side)
        const viewportWidth = window.innerWidth;
        const fullWidthWithMargins = viewportWidth - 40; // 20px margin on each side
        
        window.gameChatConfig.size.width.mobile = fullWidthWithMargins;
        // console.log('Mobile chat width updated to full width with margins:', fullWidthWithMargins);
        
        // Direct DOM manipulation for immediate effect
        const chatContainer = document.getElementById('game-chat-container');
        if (chatContainer) {
          chatContainer.style.width = `${fullWidthWithMargins}px`;
        }
        
        // Add resize listener to keep the width updated when screen size changes
        if (!window.chatResizeListenerAdded) {
          window.addEventListener('resize', () => {
            const newWidth = window.innerWidth - 40;
            const chatContainer = document.getElementById('game-chat-container');
            if (chatContainer && window.gameChatConfig.size.width.mobile === 'fullWidth') {
              chatContainer.style.width = `${newWidth}px`;
              // console.log('Adjusted chat width on resize:', newWidth);
            }
          });
          window.chatResizeListenerAdded = true;
        }
        
        // Store that we're using a responsive width
        window.gameChatConfig.size.width.mobile = 'fullWidth';
      } else {
        // Use fixed width as before
        window.gameChatConfig.size.width.mobile = width;
        // console.log('Mobile chat width updated to fixed width:', width);
        
        // Direct DOM manipulation for immediate effect
        const chatContainer = document.getElementById('game-chat-container');
        if (chatContainer) {
          chatContainer.style.width = `${width}px`;
        }
      }
    } else {
      window.gameChatConfig.size.width.desktop = width;
      // console.log('Desktop chat width updated:', width);
      
      // Direct DOM manipulation for immediate effect
      const chatContainer = document.getElementById('game-chat-container');
      if (chatContainer) {
        chatContainer.style.width = `${width}px`;
      }
    }
  };

  // Add a convenience function to apply full width with margins on mobile
  window.setMobileFullWidth = () => {
    // Calculate width as window width minus margins (20px on each side)
    const viewportWidth = window.innerWidth;
    const fullWidthWithMargins = viewportWidth - 40; // 20px margin on each side
    
    // Set initial width value
    const chatContainer = document.getElementById('game-chat-container');
    if (chatContainer) {
      chatContainer.style.width = `${fullWidthWithMargins}px`;
      // console.log('Set chat to full width with margins:', fullWidthWithMargins);
    }
    
    // Store the configuration 
    window.gameChatConfig.size.width.mobile = 'fullWidth';
    
    // Add resize listener (if not already added)
    if (!window.chatResizeListenerAdded) {
      window.addEventListener('resize', () => {
        const newWidth = window.innerWidth - 40;
        const chatContainer = document.getElementById('game-chat-container');
        if (chatContainer && window.gameChatConfig.size.width.mobile === 'fullWidth') {
          chatContainer.style.width = `${newWidth}px`;
          // console.log('Adjusted chat width on resize:', newWidth);
        }
      });
      window.chatResizeListenerAdded = true;
    }
    
    // Position at the desired location
    window.positionChat({bottom: '180px', left: '50%'}, true);
    
    return fullWidthWithMargins;
  };
  
  // Initialize responsive width on load for mobile
  if (typeof window !== 'undefined' && window.innerWidth <= 768) {
    setTimeout(() => window.setMobileFullWidth(), 1000);
  }
}

// UI configuration for Helper Character with mobile-specific options
const helperUIConfig = {
  // Character position and size
  position: {
    desktop: [-5.6, 0, 25],  // Increased Z from 15 to 25
    mobile: [-10, 0, 25]     // Increased Z from 15 to 25
  },
  scale: {
    desktop: 0.14,          // Desktop scale
    mobile: 0.14            // Mobile scale (slightly smaller)
  },
  // Character box UI
  messageBox: {
    width: {
      desktop: 390,        // Desktop width in pixels
      mobile: 320          // Mobile width in pixels (smaller)
    },
    height: {
      desktop: 400,        // Desktop height in pixels
      mobile: 350          // Mobile height in pixels
    },
    aspectRatio: {
      width: 4,            // Standard width ratio
      height: 5            // Standard height ratio (4:5 ratio)
    },
    // Add 3D position property for the chatbox
    position3D: {
      desktop: [2.5, 14, 8],  // [x, y, z] for desktop chatbox position
      mobile: [-1.8, 14.8, 5]   // [x, y, z] for mobile chatbox position - moved left and slightly down
    },
    position: {
      desktop: { top: '50%', left: '50%', transform: 'translate(-50%, -50%)' },
      mobile: { top: '50%', left: '50%', transform: 'translate(-50%, -50%)' },
      center: { top: '50%', left: '50%', transform: 'translate(-50%, -50%)' }
    },
    fontSize: {
      desktop: '14px',
      mobile: '13px'
    },
    zIndex: 1000,
  },
  // Badges for interactions
  badge: {
    size: {
      desktop: '11px',
      mobile: '10px'
    },
    position: {
      desktop: { x: 0, y: 18, z: 0 },
      mobile: { x: 0, y: 17.5, z: 1}
    },
    scale: {
      desktop: 0.6,  // Reduced by 35% (from 0.5 to 0.325)
      mobile: 0.6   // Same scale for mobile by default
    },
    // Add separate scale for "Stop Talking" badge
    stopTalkingScale: {
      desktop: 0.5,  // Larger scale for Stop Talking badge on desktop
      mobile: 0.3    // Larger scale for Stop Talking badge on mobile
    },
    // Add responsive positioning for the Stop Talking badge
    stopTalkingPosition: {
      // These values will be calculated dynamically based on screen size
      defaultY: 500, // Distance from top in pixels on Samsung Galaxy S20 Ultra
      defaultScreenHeight: 915 // Reference height for Samsung Galaxy S20 Ultra
    }
  },
  // Shadow configuration
  shadow: {
    normalColor: '#2a2a2a',  // Dark color when not near
    nearColor: '#22aa22',    // Green when near (matching ClothingShop)
    normalOpacity: 0.7,
    nearOpacity: 0.5
  }
};


// Make configuration accessible globally for real-time adjustments
if (typeof window !== 'undefined') {
  window.helperUIConfig = helperUIConfig;
  window.gameChatConfig = gameChatConfig; // Make game chat config available globally
}

// Function to hide chat when interacting with special characters
window.hideGameChatDuringInteraction = (interactionType) => {
  // Set the flag to hide the chat UI
  window.hideGameMessaging = true;
  // console.log(`Chat UI hidden while interacting with: ${interactionType}`);
};

// Function to show chat after interaction ends
window.showGameChatAfterInteraction = () => {
  // Only restore chat if it wasn't force hidden
  if (!window.forceHideGameChat) {
    // Explicitly reset all flags that might prevent the chat from showing
    window.hideGameMessaging = false;
    
    // Make sure the config is also updated
    if (window.gameChatConfig) {
      window.gameChatConfig.visible = true;
    }
    
    // console.log('Chat UI restored after interaction');
  }
};

// Helper functions for each interaction type
window.startHelperInteraction = () => {
  window.hideGameChatDuringInteraction('HelperCharacter');
};

window.startClothingShopInteraction = () => {
  window.hideGameChatDuringInteraction('ClothingShop');
};

window.startBarberShopInteraction = () => {
  window.hideGameChatDuringInteraction('BarberShop');
};

// This function is specifically designed to end ALL interactions with characters
// and restore the game chat functionality
window.endCharacterInteraction = () => {
  // Make game messaging visible again
  window.hideGameMessaging = false;
  window.hideJoystick = false;
  
  // Enable visibility of game chat UI
  if (window.gameChatConfig) {
    window.gameChatConfig.visible = true;
  }
  
  // Update chatbox open state
  window.chatboxOpen = false;
  
  // Try to find and show the game chat UI directly in the DOM
  const chatContainer = document.getElementById('game-chat-container');
  if (chatContainer) {
    chatContainer.style.display = 'block';
    // console.log('Chat UI restored after interaction');
  }
};

// Add window-level functions for responsive positioning
if (typeof window !== 'undefined') {
  // Function to calculate responsive positions for UI elements
  window.calculateResponsivePositions = () => {
    if (!window.helperUIConfig) return;
    
    const viewportHeight = window.innerHeight;
    const viewportWidth = window.innerWidth;
    
    // Reference values (Samsung Galaxy S20 Ultra)
    const referenceHeight = window.helperUIConfig.badge.stopTalkingPosition.defaultScreenHeight;
    const referenceStopTalkingY = window.helperUIConfig.badge.stopTalkingPosition.defaultY; 
    
    // Calculate proportional positioning - maintaining same visual spacing
    const heightRatio = viewportHeight / referenceHeight;
    
    // Calculate Y position for Stop Talking badge (maintaining same relative distance from top)
    const scaledStopTalkingY = referenceStopTalkingY * heightRatio;
    
    // Convert screen space to world space for the badge
    // Higher Y value = higher position in 3D space
    const badgeWorldY = 21 - (scaledStopTalkingY / viewportHeight * 8);
    
    // Update badge position
    if (window.helperUIConfig.badge && window.helperUIConfig.badge.position) {
      window.helperUIConfig.badge.position.mobile.y = badgeWorldY;
      // console.log(`Adjusted badge Y position to ${badgeWorldY} (screen height: ${viewportHeight}px)`);
    }
    
    // Update chatbox position - position it in center of screen
    if (window.helperUIConfig.messageBox && window.helperUIConfig.messageBox.position3D) {
      // Mobile chatbox offset based on screen proportions
      window.helperUIConfig.messageBox.position3D.mobile = [
        -1.6, // X position
        15, // Y position - much higher to be at face level, not at feet
        5 + (viewportWidth < 400 ? -1 : 0) // Z position - closer on narrower screens
      ];
      
      // Calculate responsive width based on screen width
      const responsiveWidth = Math.min(
        Math.round(viewportWidth * 0.8), // 80% of screen width
        400 // max width
      );
      
      // Use aspect ratio to calculate height
      const { width: ratioWidth, height: ratioHeight } = window.helperUIConfig.messageBox.aspectRatio;
      const responsiveHeight = Math.round(responsiveWidth * (ratioHeight / ratioWidth));
      
      // Set chatbox dimensions
      window.helperUIConfig.messageBox.width.mobile = responsiveWidth;
      window.helperUIConfig.messageBox.height.mobile = Math.min(
        responsiveHeight, // height based on aspect ratio
        Math.round(viewportHeight * 0.6), // max 60% of viewport height
        400 // absolute max height
      );
      
      // console.log(`Adjusted chatbox: ${responsiveWidth}x${window.helperUIConfig.messageBox.height.mobile}px (screen: ${viewportWidth}x${viewportHeight})`);
    }
    
    return {
      badgeY: badgeWorldY,
      chatboxPosition: window.helperUIConfig.messageBox.position3D.mobile
    };
  };
  
  // Call immediately and add resize listener
  if (window.innerWidth <= 768) {
    window.calculateResponsivePositions();
    
    // Add resize listener if not already added
    if (!window.helperUIPositionListenerAdded) {
      window.addEventListener('resize', () => {
        window.calculateResponsivePositions();
      });
      window.helperUIPositionListenerAdded = true;
    }
  }
}

const HelperCharacter = forwardRef((props, ref) => {
  const group = React.useRef()
  const [isNear, setIsNear] = useState(false)
  const [showChatbox, setShowChatbox] = useState(false)
  const [message, setMessage] = useState('')
  const [reply, setReply] = useState([])
  const chatContainerRef = useRef(null)
  const { scene, animations } = useGLTF('/AI_HELPER.glb')
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene])
  const { nodes, materials } = useGraph(clone)
  const { actions } = useAnimations(animations, group)
  const { camera } = useThree() // Access the camera

  // Add this line to detect mobile view
  const isMobile = useMediaQuery({ query: '(max-width: 768px)' });
  
  // Recalculate responsive positions when component mounts on mobile
  useEffect(() => {
    if (isMobile && typeof window !== 'undefined' && window.calculateResponsivePositions) {
      // Recalculate positions for this specific device
      window.calculateResponsivePositions();
    }
  }, [isMobile]);
  
  // For example, in your render function:
  // Use the appropriate scale based on device
  const scale = isMobile ? helperUIConfig.scale.mobile : helperUIConfig.scale.desktop;
  
  // Use the appropriate position based on device
  const position = isMobile ? helperUIConfig.position.mobile : helperUIConfig.position.desktop;
  
  // Later in your component
  // For the message box styling
  const messageBoxStyle = {
    width: isMobile ? helperUIConfig.messageBox.width.mobile : helperUIConfig.messageBox.width.desktop,
    fontSize: isMobile ? helperUIConfig.messageBox.fontSize.mobile : helperUIConfig.messageBox.fontSize.desktop,
    zIndex: helperUIConfig.messageBox.zIndex,
    // Remove position properties - handled by the 3D positioning now
  };
  
  // For the badge styling
  const badgeSize = isMobile ? helperUIConfig.badge.size.mobile : helperUIConfig.badge.size.desktop;
  const badgePosition = isMobile ? helperUIConfig.badge.position.mobile : helperUIConfig.badge.position.desktop;
  
  // Define a character shadow component
  const CharacterShadow = () => {
    return (
      <mesh 
        rotation={[-Math.PI / 2, 0, 0]} 
        position={[0, 0.01, 1]} 
        receiveShadow={false}
      >
        <circleGeometry args={[5, 64]} />
        <meshBasicMaterial 
          color={isNear ? helperUIConfig.shadow.nearColor : helperUIConfig.shadow.normalColor}
          transparent={true}
          opacity={isNear ? helperUIConfig.shadow.nearOpacity : helperUIConfig.shadow.normalOpacity}
          depthWrite={false}
        />
      </mesh>
    );
  };

  // Connect the forwarded ref to our group
  React.useImperativeHandle(ref, () => group.current)

  // Set up a state to track post-chat transition
  const [inPostChatTransition, setInPostChatTransition] = useState(false);
  
  // Store original rotation to return to after conversation ends
  const originalRotation = useRef([0, Math.PI / 4, 0]);
  
  // Create a ref for target rotation - moved outside useEffect
  const targetRotation = useRef(0);

  // Rotate helper to face camera when chatbox is opened
  useEffect(() => {
    if (!group.current) return;
    
    if (showChatbox) {
      // Save original rotation if not already saved
      if (!originalRotation.current) {
        originalRotation.current = [
          group.current.rotation.x,
          group.current.rotation.y,
          group.current.rotation.z
        ];
      }

      // Function to update target rotation based on camera position
      const updateTargetRotation = () => {
        if (!group.current || !camera) return;
        
        // Get positions
        const helperPos = new THREE.Vector3();
        group.current.getWorldPosition(helperPos);
        
        // Get camera position
        const cameraPos = new THREE.Vector3();
        camera.getWorldPosition(cameraPos);
        
        // Direction from helper to camera (only consider XZ plane)
        const direction = new THREE.Vector2(
          cameraPos.x - helperPos.x,
          cameraPos.z - helperPos.z
        );
        
        // Calculate target angle
        targetRotation.current = Math.atan2(direction.x, direction.y);
      };
      
      // Animation loop for smooth rotation
      const animateRotation = () => {
        if (!group.current) return;
        
        // Get current rotation and calculate the difference
        const currentRotation = group.current.rotation.y;
        let rotationDifference = targetRotation.current - currentRotation;
        
        // Handle rotation wrap-around (e.g., from 359° to 1°)
        if (rotationDifference > Math.PI) {
          rotationDifference -= Math.PI * 2;
        } else if (rotationDifference < -Math.PI) {
          rotationDifference += Math.PI * 2;
        }
        
        // Smoothly interpolate rotation
        if (Math.abs(rotationDifference) > 0.01) {
          group.current.rotation.y += rotationDifference * 0.1;
        }
      };
      
      // Update target rotation immediately and every 100ms
      updateTargetRotation();
      const targetUpdateInterval = setInterval(updateTargetRotation, 100);
      
      // Start animation loop using requestAnimationFrame for smooth rotation
      let animationFrameId;
      const animate = () => {
        animateRotation();
        animationFrameId = requestAnimationFrame(animate);
      };
      animate();
      
      // Clean up both the interval and animation frame
      return () => {
        clearInterval(targetUpdateInterval);
        cancelAnimationFrame(animationFrameId);
      };
    } else if (originalRotation.current) {
      // Smoothly return to original rotation when chat is closed
      const returnToOriginal = () => {
        if (!group.current) return;
        
        // Calculate difference between current and original rotation
        const currentRotation = group.current.rotation.y;
        const originalY = originalRotation.current[1];
        let rotationDifference = originalY - currentRotation;
        
        // Handle rotation wrap-around
        if (rotationDifference > Math.PI) {
          rotationDifference -= Math.PI * 2;
        } else if (rotationDifference < -Math.PI) {
          rotationDifference += Math.PI * 2;
        }
        
        // Smoothly transition back to original rotation
        if (Math.abs(rotationDifference) > 0.01) {
          group.current.rotation.y += rotationDifference * 0.1;
          requestAnimationFrame(returnToOriginal);
        } else {
          // Once we're close enough, set exact values
          group.current.rotation.x = originalRotation.current[0];
          group.current.rotation.y = originalRotation.current[1];
          group.current.rotation.z = originalRotation.current[2];
        }
      };
      
      // Start the return animation
      returnToOriginal();
    }
  }, [showChatbox, camera]);

  // Set global flag when chatbox state changes
  useEffect(() => {
    window.chatboxOpen = showChatbox;
    
    // If transitioning from open to closed, start transition period
    if (!showChatbox && !inPostChatTransition) {
      setInPostChatTransition(true);
      // Exit transition period after camera has had time to reposition
      setTimeout(() => {
        setInPostChatTransition(false);
      }, 1500); // 1.5 second transition time (increased from 1 second)
    }
    
    
    return () => {
      window.chatboxOpen = false;
    }
  }, [showChatbox, inPostChatTransition]);
  
  // Make the post-chat transition state available globally
  useEffect(() => {
    window.inChatTransition = inPostChatTransition;
  }, [inPostChatTransition]);

  // Set up the initial pose (Animation4) and animations
  useEffect(() => {
    if (!actions) return;
    
    // Log available animations for debugging
    console.log("Available animations:", Object.keys(actions));
    
    // Find Animation4 and Animation5
    const idleAnimation = actions['Animation4'] || Object.values(actions)[3]; // Fallback to 4th animation if not named
    const talkAnimation = actions['Animation5'] || Object.values(actions)[4]; // Fallback to 5th animation if not named
    
    // Set up animations with appropriate settings
    if (idleAnimation) {
      idleAnimation.reset();
      idleAnimation.setEffectiveTimeScale(1);
      idleAnimation.setLoop(THREE.LoopRepeat, Infinity);
      idleAnimation.clampWhenFinished = false;
      idleAnimation.play();
    }
    
    if (talkAnimation) {
      talkAnimation.reset();
      talkAnimation.setEffectiveTimeScale(1);
      talkAnimation.setLoop(THREE.LoopRepeat, Infinity);
      talkAnimation.clampWhenFinished = false;
      // Don't play it yet - we'll play it when needed
      talkAnimation.stop();
    }
    
    // Store animations in refs for later use
    window.helperAnimations = {
      idle: idleAnimation,
      talk: talkAnimation
    };
    
  }, [actions]);
  
  // Handle animations based on chatbox state and reply changes
  useEffect(() => {
    if (!window.helperAnimations?.idle || !window.helperAnimations?.talk) return;
    
    const { idle, talk } = window.helperAnimations;
    
    // Only trigger on chatbox close or open, not on every reply change
    // (The reply-based animation is now handled in handleSubmit)
    if (!showChatbox) {
      // When chatbox is closed, ensure we're in idle state
      
      // Stop any running animation transition
      if (window.animationTransitionTimeout) {
        clearTimeout(window.animationTransitionTimeout);
      }
      
      // Crossfade between animations
      talk.fadeOut(0.3);
      idle.reset();
      idle.fadeIn(0.3);
      idle.play();
    }
    
    // Cleanup
    return () => {
      if (window.animationTransitionTimeout) {
        clearTimeout(window.animationTransitionTimeout);
      }
    };
  }, [showChatbox]);

  // Simplified proximity detection without characterRef
  useEffect(() => {
    // Set a static value for isNear instead of checking proximity
    setIsNear(true);
    
    // For demonstration purposes, check if camera is near the helper
    if (camera) {
      const checkProximity = () => {
        if (!group.current) return;
        
        const helperPos = new THREE.Vector3();
        group.current.getWorldPosition(helperPos);
        
        const cameraPos = new THREE.Vector3();
        camera.getWorldPosition(cameraPos);
        
        const distance = cameraPos.distanceTo(helperPos);
        const newIsNear = distance < 15; // Larger radius for detection
        setIsNear(newIsNear);
        
        // If user walks away while chatbox is open, close it
        if (showChatbox && !newIsNear) {
          setShowChatbox(false);
          setMessage('');
          setReply([]);
        }
      };
      
      // Check proximity every 100ms
      const interval = setInterval(checkProximity, 100);
      return () => clearInterval(interval);
    }
  }, [camera, showChatbox]);
  
  // Set initial welcome message when chatbox opens
  useEffect(() => {
    if (showChatbox && reply.length === 0) {
      // Add welcome message when chatbox is opened for the first time
      setReply([
        { sender: 'ai', text: "Hi, I'm an AI assistant, how can I help?" }
      ])
    }
  }, [showChatbox, reply.length])
  
  // Auto-scroll to bottom when messages change
  useEffect(() => {
    if (chatContainerRef.current) {
      chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight
    }
  }, [reply])
  
  // Handle chat submission
  const handleSubmit = (e) => {
    e.preventDefault()
    if (message.trim()) {
      // Store user message and AI response
      const userMessage = message
      
      // Add user message immediately
      setReply(prev => [
        ...prev,
        { sender: 'user', text: userMessage }
      ])
      
      // Clear input field
      setMessage('')
      
      // Generate AI response based on user message
      let aiResponse = "Hi, I'm an AI assistant, how can I help?"
      
      // Simple response patterns for a more interactive feel
      const lowerMessage = userMessage.toLowerCase()
      if (lowerMessage.includes('hello') || lowerMessage.includes('hi')) {
        aiResponse = "Hello there! How can I assist you today?"
      } else if (lowerMessage.includes('how are you')) {
        aiResponse = "I'm doing well, thanks for asking! How can I help you?"
      } else if (lowerMessage.includes('help')) {
        aiResponse = "I'd be happy to help! What do you need assistance with?"
      } else if (lowerMessage.includes('thank')) {
        aiResponse = "You're welcome! Is there anything else you'd like to know?"
      } else if (lowerMessage.includes('bye') || lowerMessage.includes('goodbye')) {
        aiResponse = "Goodbye! Feel free to chat again if you need anything."
      }
      
      // Add AI response with a slight delay to simulate thinking
      setTimeout(() => {
        setReply(prev => [
          ...prev,
          { sender: 'ai', text: aiResponse }
        ])
        
        // Start talking animation - but first check if we have animations
        if (window.helperAnimations?.idle && window.helperAnimations?.talk) {
          const { idle, talk } = window.helperAnimations;
          
          console.log("Starting AI response animation");
          // Crossfade to talking animation
          idle.fadeOut(0.3);
          talk.reset();
          talk.fadeIn(0.3);
          talk.play();
          
          // Calculate duration based on message length
          // For better timing, count words rather than characters
          const wordCount = aiResponse.split(/\s+/).length;
          // Average speaking rate - approximately 2-3 words per second
          const speakingDuration = Math.max(2, Math.min(8, wordCount / 2.5));
          
          console.log(`AI response animation duration: ${speakingDuration}s (${wordCount} words)`);
          
          // After message "speaking" duration, transition back to idle
          if (window.animationTransitionTimeout) {
            clearTimeout(window.animationTransitionTimeout);
          }
          
          window.animationTransitionTimeout = setTimeout(() => {
            console.log("AI finished talking - returning to idle");
            talk.fadeOut(0.3);
            idle.reset();
            idle.fadeIn(0.3);
            idle.play();
          }, speakingDuration * 1000);
        }
      }, 500)
    }
  }

  // Function to safely open the chatbox
  const openChatbox = () => {
    console.log("Opening chatbox from shared function");
    setShowChatbox(true);
    
    // Use direct DOM manipulation to hide game chat immediately
    window.directlyHideChatUI(true);
    
    // Start helper interaction to hide game chat
    window.startHelperInteraction();
    console.log("Started helper interaction, hiding chat");
    
    // Ensure the global flags are updated immediately
    window.chatboxOpen = true;
    window.hideJoystick = true; // Hide joystick UI
    
    // Calculate appropriate chatbox size for current device
    setTimeout(calculateChatboxSize, 100);
    
    // Position the player character and camera consistently for conversation
    if (window.cameraConfig && camera && group.current) {
      // Get the helper character's position
      const helperPos = new THREE.Vector3();
      group.current.getWorldPosition(helperPos);
      
      // Store original camera settings
      const originalDistance = window.cameraConfig.distance;
      const originalHeight = window.cameraConfig.height;
      
      // Set fixed camera position for conversation
      // This ensures consistent view across all devices
      window.cameraConfig.helperFocus.active = true;
      window.cameraConfig.helperFocus.transitionSpeed = 3;
      window.cameraConfig.distance = 7; // Closer to see the character well
      window.cameraConfig.height = 3; // Eye level with character
      
      // Position player character in front of the helper character
      if (window.characterRef?.current) {
        // Save original position and rotation before moving
        if (!originalPlayerPosition.current) {
          originalPlayerPosition.current = window.characterRef.current.position.clone();
          originalPlayerRotation.current = window.characterRef.current.rotation.y;
          console.log("Saved original player position:", originalPlayerPosition.current);
        }
        
        // Calculate optimal position in front of helper character
        // Get normalized vector pointing from helper to camera
        const cameraPos = new THREE.Vector3();
        camera.getWorldPosition(cameraPos);
        
        // Direction vector from helper to camera, projected onto XZ plane
        const direction = new THREE.Vector2(
          cameraPos.x - helperPos.x,
          cameraPos.z - helperPos.z
        ).normalize();
        
        // Position player at fixed distance in front of helper
        const distanceFromHelper = 4; // 4 units in front of helper
        const playerPos = new THREE.Vector3(
          helperPos.x - direction.x * distanceFromHelper,
          0, // Keep on ground
          helperPos.z - direction.y * distanceFromHelper
        );
        
        // Move player character to this position
        window.characterRef.current.position.copy(playerPos);
        
        // Rotate player to face helper
        const angle = Math.atan2(-direction.x, -direction.y);
        window.characterRef.current.rotation.y = angle;
        
        console.log("Positioned player character in front of helper");
      }
      
      console.log("Camera positioned for helper character conversation");
    }
  }
  
  // Function to safely close the chatbox
  const closeChatbox = () => {
    // console.log("Closing chatbox from shared function");
    // First update state
    setShowChatbox(false);
    setMessage('');
    setReply([]);
    
    // Ensure the global flags are updated immediately
    window.chatboxOpen = false;
    window.hideJoystick = false; // Show joystick again
    
    // Make sure the hideGameMessaging flag is reset AFTER state updates
    // to ensure proper cleanup
    setTimeout(() => {
      // Use direct DOM manipulation to show game chat
      window.directlyHideChatUI(false);
      
      // End interaction to restore game chat AFTER all state is updated
      window.endCharacterInteraction();
      // console.log("Released chat after helper interaction ended");
    }, 100);
    
    // Force camera transition to complete by manipulating camera config temporarily
    if (window.cameraConfig) {
      // Store original values
      const originalDistance = window.cameraConfig.distance;
      const originalTransitionSpeed = window.cameraConfig.helperFocus.transitionSpeed;
      const originalReturnSpeed = window.cameraConfig.returnSpeed;
      const originalHeight = window.cameraConfig.height;
      
      // Turn off helper focus mode
      window.cameraConfig.helperFocus.active = false;
      
      // Restore player character position and rotation
      if (window.characterRef?.current && originalPlayerPosition.current) {
        // Wait a moment to ensure the camera has started moving back
        setTimeout(() => {
          window.characterRef.current.position.copy(originalPlayerPosition.current);
          window.characterRef.current.rotation.y = originalPlayerRotation.current;
          // console.log("Restored player character position and rotation");
          
          // Reset saved position
          originalPlayerPosition.current = null;
          originalPlayerRotation.current = null;
        }, 300);
      }
      
      // Temporarily boost transition speeds for immediate effect - but not too fast
      window.cameraConfig.helperFocus.transitionSpeed = 5; // Reduced from 10 for smoother transition
      window.cameraConfig.returnSpeed = 0.25; // Reduced from 0.5 for smoother transition
      
      // Temporarily increase distance for more zoom out, but not excessively
      window.cameraConfig.distance = 11.0; // Slightly less than before (was 12.0)
      
      // Restore original values after transition completes
      setTimeout(() => {
        // First step: reduce boosted values gradually
        window.cameraConfig.helperFocus.transitionSpeed = originalTransitionSpeed * 1.5;
        window.cameraConfig.returnSpeed = originalReturnSpeed * 1.5;
        window.cameraConfig.distance = originalDistance * 1.1;
        window.cameraConfig.height = originalHeight;
        
        // Final step: restore original values completely
        setTimeout(() => {
          window.cameraConfig.helperFocus.transitionSpeed = originalTransitionSpeed;
          window.cameraConfig.returnSpeed = originalReturnSpeed;
          window.cameraConfig.distance = originalDistance;
          window.cameraConfig.height = originalHeight;
        }, 500);
      }, 500);
    }
  }

  // Store original player character position and rotation
  const originalPlayerPosition = useRef(null);
  const originalPlayerRotation = useRef(null);

  // Store references to chatbox elements
  const chatboxRef = useRef(null);
  const calculateChatboxSize = () => {
    // Get outer chatbox element and inner message container
    const chatbox = document.querySelector('.helper-chatbox-wrapper');
    const messageContainer = document.querySelector('.helper-chat-messages');
    
    if (!chatbox || !messageContainer) return;
    
    // Get viewport dimensions
    const viewportHeight = window.innerHeight;
    const viewportWidth = window.innerWidth;
    
    // Calculate appropriate sizes and positions based on viewport
    let chatboxWidth, messagesHeight;
    
    // Responsive Width based on viewport width
    chatboxWidth = Math.min(
      Math.round(viewportWidth * 0.85), // 85% of screen width
      450 // max width
    ) + 'px';
    
    // Responsive Message Area Height
    if (viewportHeight < 600) {
      // Very small screens - compact chat
      messagesHeight = 'calc(60vh - 80px)';
    } else if (viewportHeight < 800) {
      // Medium screens
      messagesHeight = 'calc(55vh - 90px)';
    } else {
      // Larger screens
      messagesHeight = 'calc(50vh - 100px)';
    }
    
    // Apply calculated values
    chatbox.style.width = chatboxWidth;
    // Note: We don't set chatbox height directly, let content define it with maxHeight
    // chatbox.style.maxHeight is already set in the initial style
    
    messageContainer.style.height = messagesHeight;
  };
  
  // Handle screen rotation or size changes
  useEffect(() => {
    const handleResize = () => {
      // Only run if chatbox is open AND on mobile
      if (showChatbox && isMobile) {
        calculateChatboxSize();
      }
    };
    
    // Calculate initial size only if open and on mobile
    if (showChatbox && isMobile) {
      // Small delay to ensure DOM is updated
      setTimeout(calculateChatboxSize, 100);
    }
    
    // Add resize listener
    window.addEventListener('resize', handleResize);
    
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, [showChatbox, isMobile]); // Add isMobile dependency

  // Function to restore chat UI for all non-interaction cases
  const restoreChatUI = () => {
    window.hideGameMessaging = false;
    window.hideJoystick = false;
    
    // Update the chat config visibility
    if (window.gameChatConfig) {
      window.gameChatConfig.visible = true;
    }
    
    // Remove special interaction states
    window.chatboxOpen = false;
    
    // Try to immediately update DOM if possible
    const chatContainer = document.getElementById('game-chat-container');
    if (chatContainer) {
      chatContainer.style.display = 'block';
      // console.log("Chat UI restored after interaction");
    }
  };

  return (
    <group 
      ref={group} 
      dispose={null} 
      scale={scale} 
      position={position} 
      rotation={[0, Math.PI / 4, 0]}
    >
      {/* Character shadow */}
      <CharacterShadow />
      
      {/* Badge above character - only show when not in chat mode */}
      {!showChatbox && (
      <Html
          position={[
            isMobile ? helperUIConfig.badge.position.mobile.x : helperUIConfig.badge.position.desktop.x,
            isMobile ? helperUIConfig.badge.position.mobile.y : helperUIConfig.badge.position.desktop.y,
            isMobile ? helperUIConfig.badge.position.mobile.z : helperUIConfig.badge.position.desktop.z
          ]}
        center
          wrapperClass="helper-badge-wrapper"
          distanceFactor={15}
          onClick={(e) => {
            // console.log("HTML Badge wrapper clicked");
            e.stopPropagation();
            if (isNear) {
              console.log("HTML Badge wrapper: Opening chatbox...");
              openChatbox();
            }
          }}
        >
          <button
            className="helper-badge"
            onClick={(e) => {
              e.stopPropagation();
              e.preventDefault();
              console.log("Button Badge clicked directly");
              
              if (isNear) {
                console.log("Badge Button: Opening chatbox...");
                openChatbox();
              }
            }}
        style={{
              background: isNear ? helperUIConfig.shadow.nearColor : helperUIConfig.shadow.normalColor,
              padding: '10px 16px',
              borderRadius: '10px',
              color: 'white',
              fontSize: '16px',
              fontWeight: '600',
              whiteSpace: 'nowrap',
              userSelect: 'none',
              fontFamily: 'system-ui, -apple-system, sans-serif',
              boxShadow: '0 3px 6px rgba(0,0,0,0.3)',
              border: '2px solid white',
              transition: 'all 0.3s ease',
              transform: `scale(${isMobile ? helperUIConfig.badge.scale.mobile : helperUIConfig.badge.scale.desktop})`,
              cursor: isNear ? 'pointer' : 'default',
              pointerEvents: 'auto',
              zIndex: 1000,
              opacity: 0.9,
            }}
      >
        {isNear ? "Talk with me" : "AI Helper"}
          </button>
        </Html>
      )}
      
      {/* Stop talking button - only shown when in chat mode */}
      {showChatbox && (
        <Html
          position={[
            isMobile ? helperUIConfig.badge.position.mobile.x : helperUIConfig.badge.position.desktop.x,
            isMobile ? helperUIConfig.badge.position.mobile.y : helperUIConfig.badge.position.desktop.y,
            isMobile ? helperUIConfig.badge.position.mobile.z : helperUIConfig.badge.position.desktop.z
          ]}
          center
          wrapperClass="helper-badge-wrapper"
          distanceFactor={15}
        >
          <button
            className="helper-badge"
            onClick={(e) => {
              e.stopPropagation();
              console.log("Stop Talking button clicked");
              closeChatbox();
            }}
            style={{
              background: '#e74c3c',
              padding: '10px 16px',
              borderRadius: '10px',
              color: 'white',
              fontSize: '16px',
              fontWeight: '600',
              whiteSpace: 'nowrap',
              userSelect: 'none',
              fontFamily: 'system-ui, -apple-system, sans-serif',
              boxShadow: '0 3px 6px rgba(0,0,0,0.3)',
              border: '2px solid white',
              transform: `scale(${isMobile ? helperUIConfig.badge.stopTalkingScale.mobile : helperUIConfig.badge.stopTalkingScale.desktop})`,
              cursor: 'pointer',
              zIndex: 1010,
              opacity: 0.9,
            }}
          >
            Stop talking
          </button>
        </Html>
      )}
      
      {/* Chatbox popup */}
      {showChatbox && (
        <Html
          ref={chatboxRef}
          // Use 3D position for both desktop and mobile
          position={isMobile ? helperUIConfig.messageBox.position3D.mobile : helperUIConfig.messageBox.position3D.desktop}
          wrapperClass="helper-chatbox-wrapper"
          // Apply styles conditionally
          style={isMobile ? {
            // Mobile styles (viewport-based sizing, positioned by Html)
            width: `${helperUIConfig.messageBox.width.mobile}px`, // Initial width, adjusted dynamically
            height: `${helperUIConfig.messageBox.height.mobile}px`, // Initial height, adjusted dynamically
            background: '#2a2a2a',
            borderRadius: '8px',
            boxShadow: '0 3px 9px rgba(0,0,0,0.3)',
            padding: '12px',
            fontFamily: 'system-ui, -apple-system, sans-serif',
            pointerEvents: 'auto',
            color: 'white',
            zIndex: helperUIConfig.messageBox.zIndex,
            // Removed fixed positioning, top, left, transform - let Html handle it
            overflow: 'hidden', 
            fontSize: '11px',
            display: 'flex', // Added flex for vertical layout
            flexDirection: 'column' // Added flex for vertical layout
          } : {
            // Desktop styles (fixed size, positioned by Html component)
            width: `${helperUIConfig.messageBox.width.desktop}px`,
            height: `${helperUIConfig.messageBox.height.desktop}px`,
            background: '#2a2a2a',
            borderRadius: '10px',
            boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
            padding: '16px',
            fontFamily: 'system-ui, -apple-system, sans-serif',
            pointerEvents: 'auto',
            color: 'white',
            zIndex: helperUIConfig.messageBox.zIndex,
            fontSize: helperUIConfig.messageBox.fontSize.desktop, // Use desktop font size
            display: 'flex', // Use flexbox for desktop layout
            flexDirection: 'column' // Stack elements vertically
          }}
        >
          <div style={{ position: 'relative', height: '100%', display: 'flex', flexDirection: 'column' }} onClick={(e) => e.stopPropagation()}>
            {/* Close button - Adjust styles if needed for desktop */}
            <button
              onClick={(e) => {
                e.stopPropagation(); // Prevent event propagation
                console.log("X button: Closing chatbox...");
                closeChatbox();
              }}
              style={{
                position: 'absolute',
                top: isMobile ? '-4px' : '5px', // Different position for desktop
                right: isMobile ? '-4px' : '5px', // Different position for desktop
                background: '#e74c3c',
                color: 'white',
                border: 'none',
                borderRadius: '50%',
                width: isMobile ? '20px' : '24px', // Slightly larger on desktop
                height: isMobile ? '20px' : '24px',
                cursor: 'pointer',
                fontSize: isMobile ? '12px' : '14px',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                boxShadow: '0 1px 3px rgba(0,0,0,0.2)',
                zIndex: 10 // Ensure it's above other chatbox content
              }}
            >
              ✕
            </button>
            
            {/* Messages Container - Adjust styles for desktop */}
            <div 
              ref={chatContainerRef}
              className="helper-chat-messages"
              style={isMobile ? {
                // Mobile message container styles
                height: 'calc(45vh - 80px)', // Will be adjusted by calculateChatboxSize
                marginBottom: '8px',
                padding: '8px',
                background: '#333',
                borderRadius: '6px',
                overflowY: 'auto',
                display: 'flex',
                flexDirection: 'column',
                scrollbarWidth: 'thin',
                scrollbarColor: '#555 #333',
              } : {
                // Desktop message container styles
                flexGrow: 1, // Allow it to fill available space
                marginBottom: '10px',
                padding: '10px',
                background: '#333',
                borderRadius: '8px',
                overflowY: 'auto',
                display: 'flex',
                flexDirection: 'column',
                // Add webkit scrollbar styles directly for desktop if needed
              }}
            >
              {/* Message rendering logic (no changes needed here) */}
              {reply.length > 0 ? (
                reply.map((msg, index) => (
                  <div 
                    key={index}
                    style={{
                      background: msg.sender === 'ai' ? '#37BA7E' : '#555',
                      padding: isMobile ? '6px 10px' : '8px 12px',
                      borderRadius: isMobile ? '10px' : '12px',
                      marginBottom: isMobile ? '6px' : '8px',
                      marginLeft: msg.sender === 'ai' ? '0' : 'auto',
                      marginRight: msg.sender === 'ai' ? 'auto' : '0',
                      maxWidth: isMobile ? '75%' : '80%',
                      color: 'white',
                      alignSelf: msg.sender === 'ai' ? 'flex-start' : 'flex-end',
                      textAlign: msg.sender === 'ai' ? 'left' : 'right',
                      wordBreak: 'break-word',
                      fontSize: isMobile ? '11px' : helperUIConfig.messageBox.fontSize.desktop, // Use appropriate font size
                    }}
                  >
                    {msg.text}
                  </div>
                ))
              ) : (
                <div style={{
                  textAlign: 'center',
                  color: '#888',
                  marginTop: 'auto',
                  marginBottom: 'auto',
                  fontSize: isMobile ? '10px' : '12px' // Adjust placeholder size
                }}>
                  Type a message to start chatting
                </div>
              )}
            </div>
            
            {/* Input Form - Adjust styles for desktop */}
            <form onSubmit={handleSubmit} className="helper-chat-form" style={{ display: 'flex', flexShrink: 0 /* Prevent form from shrinking */ }}>
              <input
                type="text"
                value={message}
                onChange={(e) => setMessage(e.target.value)}
                placeholder="Type a message..."
                className="helper-chat-input"
                style={isMobile ? {
                  // Mobile input styles
                  flex: 1,
                  padding: '6px 10px',
                  borderRadius: '16px',
                  border: '1px solid #444',
                  outline: 'none',
                  background: '#333',
                  color: 'white',
                  fontSize: '11px',
                } : {
                  // Desktop input styles
                  flex: 1,
                  padding: '8px 12px',
                  borderRadius: '20px',
                  border: '1px solid #444',
                  outline: 'none',
                  background: '#333',
                  color: 'white',
                  fontSize: helperUIConfig.messageBox.fontSize.desktop,
                }}
              />
              <button
                type="submit"
                className="helper-chat-button"
                style={isMobile ? {
                  // Mobile button styles
                  background: '#37BA7E',
                  color: 'white',
                  border: 'none',
                  borderRadius: '16px',
                  padding: '6px 12px',
                  marginLeft: '6px',
                  cursor: 'pointer',
                  boxShadow: '0 1px 3px rgba(0,0,0,0.2)',
                  fontSize: '11px',
                } : {
                   // Desktop button styles
                  background: '#37BA7E',
                  color: 'white',
                  border: 'none',
                  borderRadius: '20px',
                  padding: '8px 16px',
                  marginLeft: '8px',
                  cursor: 'pointer',
                  boxShadow: '0 2px 4px rgba(0,0,0,0.2)',
                  fontSize: helperUIConfig.messageBox.fontSize.desktop,
                }}
              >
                Send
              </button>
            </form>
          </div>
      </Html>
      )}
      
      {/* Character model */}
      <group name="Main" onClick={(e) => {
        console.log("Character model clicked, chatbox state:", showChatbox);
        if (isNear && !showChatbox) {
          // Only open the chatbox if it's not already open
          console.log("Character model: Opening chatbox...");
          openChatbox();
        }
      }}>
        {/* Invisible clickable area around character to make clicking easier */}
        <mesh 
          visible={false} 
          position={[0, 10, 0]}
          onClick={(e) => {
            console.log("Invisible click area triggered");
            e.stopPropagation();
            if (isNear && !showChatbox) {
              console.log("Invisible area: Opening chatbox...");
              openChatbox();
            }
          }}
        >
          <boxGeometry args={[15, 20, 15]} />
          <meshBasicMaterial transparent opacity={0} />
        </mesh>
        
        <group name="James_SoftwareEngineer_rig">
          <skinnedMesh
            name="Headphones"
            geometry={nodes.Headphones.geometry}
            material={materials.MAT_Headphone}
            skeleton={nodes.Headphones.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="James_5FingerHandArms001"
            geometry={nodes.James_5FingerHandArms001.geometry}
            material={materials.skin_Baked}
            skeleton={nodes.James_5FingerHandArms001.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="james_body_geo002"
            geometry={nodes.james_body_geo002.geometry}
            material={materials.skin_Baked}
            skeleton={nodes.james_body_geo002.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="james_cap001"
            geometry={nodes.james_cap001.geometry}
            material={materials.james_cap_Baked}
            skeleton={nodes.james_cap001.skeleton}
            castShadow
            receiveShadow
            material-color={isNear ? helperUIConfig.shadow.nearColor : helperUIConfig.shadow.normalColor}
          />
          <skinnedMesh
            name="james_facial_hair"
            geometry={nodes.james_facial_hair.geometry}
            material={materials['Facial hair']}
            skeleton={nodes.james_facial_hair.skeleton}
            castShadow
            receiveShadow
          />
          <group name="james_hair_geo002">
            <skinnedMesh
              name="james_hair_geo002_1"
              geometry={nodes.james_hair_geo002_1.geometry}
              material={materials.James_hairbase}
              skeleton={nodes.james_hair_geo002_1.skeleton}
              castShadow
              receiveShadow
            />
            <skinnedMesh
              name="james_hair_geo002_2"
              geometry={nodes.james_hair_geo002_2.geometry}
              material={materials.Hair}
              skeleton={nodes.james_hair_geo002_2.skeleton}
              castShadow
              receiveShadow
            />
          </group>
          <skinnedMesh
            name="james_lf_eye_geo001"
            geometry={nodes.james_lf_eye_geo001.geometry}
            material={materials['James_eyes.001']}
            skeleton={nodes.james_lf_eye_geo001.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="james_lowerteeth_geo001"
            geometry={nodes.james_lowerteeth_geo001.geometry}
            material={materials['James_Mouth.001']}
            skeleton={nodes.james_lowerteeth_geo001.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="james_pants_geo001"
            geometry={nodes.james_pants_geo001.geometry}
            material={materials['james_pants_geo.003_Baked']}
            skeleton={nodes.james_pants_geo001.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="james_rt_eyebrow_geo001"
            geometry={nodes.james_rt_eyebrow_geo001.geometry}
            material={materials.James_hairbase}
            skeleton={nodes.james_rt_eyebrow_geo001.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="james_shirt_geo"
            geometry={nodes.james_shirt_geo.geometry}
            material={materials['James_Shirt.001']}
            skeleton={nodes.james_shirt_geo.skeleton}
            castShadow
            receiveShadow
            material-color={isNear ? helperUIConfig.shadow.nearColor : helperUIConfig.shadow.normalColor}
          />
          <skinnedMesh
            name="james_Tongue"
            geometry={nodes.james_Tongue.geometry}
            material={materials['James_Mouth.001']}
            skeleton={nodes.james_Tongue.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="james_upperteeth_geo"
            geometry={nodes.james_upperteeth_geo.geometry}
            material={materials['James_Mouth.001']}
            skeleton={nodes.james_upperteeth_geo.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="james_vans_geo001"
            geometry={nodes.james_vans_geo001.geometry}
            material={materials.james_vans_geo_Baked}
            skeleton={nodes.james_vans_geo001.skeleton}
            castShadow
            receiveShadow
          />
          <primitive object={nodes.Bone} />
          <primitive object={nodes.HeadphoneRoot} />
          <primitive object={nodes.MacbookRoot} />
          <primitive object={nodes.rootx} />
          <primitive object={nodes.footl} />
          <primitive object={nodes.thigh_twistl} />
          <primitive object={nodes.footr} />
          <primitive object={nodes.thigh_twistr} />
          <primitive object={nodes.spine_01x} />
          <primitive object={nodes.spine_02x} />
          <primitive object={nodes.neckx} />
          <primitive object={nodes.shoulderr} />
          <primitive object={nodes.c_arm_twist_offsetr} />
          <primitive object={nodes.arm_stretchr} />
          <primitive object={nodes.shoulderl} />
          <primitive object={nodes.c_arm_twist_offsetl} />
          <primitive object={nodes.arm_stretchl} />
          <primitive object={nodes.spine_03x} />
          <primitive object={nodes.headx} />
          <primitive object={nodes.leg_stretchl} />
          <primitive object={nodes.leg_stretchr} />
          <primitive object={nodes.forearm_stretchl} />
          <primitive object={nodes.forearm_stretchr} />
          <primitive object={nodes.handl} />
          <primitive object={nodes.handr} />
        </group>
      </group>
    </group>
  )
})

export default HelperCharacter

useGLTF.preload('/AI_HELPER.glb')
