/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 helper.glb --transform 
Files: helper.glb [41.96MB] > D:\Code\readydeveloperme\public\helper-transformed.glb [10.2MB] (76%)
*/

import React, { useEffect, useState, useRef, forwardRef } from 'react'
import { useGraph, useThree } from '@react-three/fiber'
import { useGLTF, useAnimations, Html } from '@react-three/drei'
import { SkeletonUtils } from 'three-stdlib'
import * as THREE from 'three'
import { useMediaQuery } from 'react-responsive'

// TypeScript declarations for global variables
/** @typedef {Object} HelperUIConfig
 * @property {Object} badge - Badge configuration
 * @property {Object} badge.position - Badge position values
 * @property {number} badge.position.x - Left/right position
 * @property {number} badge.position.y - Up/down position (height)
 * @property {number} badge.position.z - Forward/back position
 * @property {number} badge.scale - Scale when active
 * @property {Object} chatbox - Chatbox configuration
 * @property {Object} chatbox.position - Position values
 * @property {number} chatbox.position.x - Left/right position
 * @property {number} chatbox.position.y - Up/down position
 * @property {number} chatbox.position.z - Forward/back position
 * @property {number} chatbox.scale - Size scale
 * @property {number} chatbox.width - Width in pixels
 * @property {number} chatbox.height - Height in pixels
 * @property {Object} shadow - Shadow configuration
 * @property {Object} shadow.colors - Shadow color configuration
 * @property {string} shadow.colors.default - Default shadow color
 * @property {string} shadow.colors.near - Shadow color when near
 * @property {Object} shadow.opacity - Shadow opacity configuration
 * @property {number} shadow.opacity.default - Default opacity
 * @property {number} shadow.opacity.near - Opacity when near
 */

// Add global styles to ensure HTML overlays work properly
const styleElement = document.createElement('style');
styleElement.innerHTML = `
  .helper-badge-wrapper {
    pointer-events: auto !important;
    cursor: pointer;
    z-index: 1001 !important;
  }
  
  .helper-badge {
    cursor: pointer !important;
  }
  
  .helper-chatbox-wrapper {
    pointer-events: auto !important;
    z-index: 999 !important;
  }
`;
document.head.appendChild(styleElement);

// Create a global movement control state that can be accessed by the movement controller
window.chatboxOpen = false
// Global flag to hide/show game messaging UI
window.hideGameMessaging = false
// Global flag to hide/show joystick
window.hideJoystick = false

// Game chat messaging UI configuration
const gameChatConfig = {
  // Main controls
  visible: true,     // Set to false to hide the chat UI completely
  opacity: 0.9,      // Default opacity
  
  // Positioning
  position: {
    desktop: { bottom: '20px', left: '50%' }, // Desktop position (CSS properties) - centered
    mobile: { bottom: '180px', left: '50%' }   // Mobile position (CSS properties) - centered
  },
  // Sizing
  size: {
    width: {
      desktop: 400,  // Width in pixels for desktop
      mobile: 'fullWidth'    // Mobile width is responsive by default
    },
    height: {
      desktop: 'auto', // Height for desktop
      mobile: 'auto'   // Height for mobile
    }
  }
};

// Create a direct control function to manage chat UI
if (typeof window !== 'undefined') {
  // Add global flag to force hide chat
  window.forceHideGameChat = false;
  
  // Function to force hide chat UI (with persistence)
  window.forceHideChatUI = (hide = true) => {
    // Set global flag
    window.forceHideGameChat = hide;
    
    // Set a cookie for persistence between reloads
    document.cookie = `forceHideGameChat=${hide ? 'true' : 'false'}; path=/; max-age=86400`;
    
    // Try to also update the DOM element directly for immediate effect
    try {
      const chatContainer = document.getElementById('game-chat-container');
      if (chatContainer) {
        chatContainer.style.display = hide ? 'none' : 'block';
        console.log(`Directly ${hide ? 'hid' : 'showed'} chat container via DOM manipulation`);
      }
    } catch (err) {
      console.error('Error manipulating chat container:', err);
    }
    
    // Make sure game chat config is updated too
    if (window.gameChatConfig) {
      window.gameChatConfig.visible = !hide;
    }
    
    return hide;
  };
  
  // Expose the DOM direct manipulation function
  window.directlyHideChatUI = (hide = true) => {
    // First, update all the visibility flags
    window.hideGameMessaging = hide;
    
    if (window.gameChatConfig) {
      window.gameChatConfig.visible = !hide;
    }
    
    // Then directly manipulate the DOM for immediate effect
    const chatContainer = document.getElementById('game-chat-container');
    if (chatContainer) {
      chatContainer.style.display = hide ? 'none' : 'block';
      console.log(`Directly ${hide ? 'hiding' : 'showing'} chat container via DOM manipulation`);
    } else {
      console.log('Chat container element not found in DOM');
    }
  };
  
  // Check for the cookie on page load
  const checkChatVisibilityCookie = () => {
    const cookieValue = document.cookie
      .split('; ')
      .find(row => row.startsWith('forceHideGameChat='))
      ?.split('=')[1];
      
    if (cookieValue === 'true') {
      window.forceHideGameChat = true;
      setTimeout(() => {
        const chatContainer = document.getElementById('game-chat-container');
        if (chatContainer) {
          chatContainer.style.display = 'none';
          console.log('Chat UI hidden based on saved preference');
        }
      }, 500); // Small delay to ensure DOM is ready
    }
  };
  
  // Call the function to check cookie
  checkChatVisibilityCookie();
  
  // Function to toggle chat visibility
  window.toggleChat = (visible) => {
    window.gameChatConfig.visible = visible;
    window.hideGameMessaging = !visible;
    
    // Direct DOM manipulation for immediate effect
    const chatContainer = document.getElementById('game-chat-container');
    if (chatContainer) {
      chatContainer.style.display = visible ? 'block' : 'none';
      console.log(`Chat UI is now ${visible ? 'visible' : 'hidden'} (DOM updated directly)`);
    } else {
      console.log(`Chat UI is now ${visible ? 'visible' : 'hidden'} (waiting for DOM update)`);
    }
  };

  // Function to position chat
  window.positionChat = (position, isMobile = false) => {
    // Example: {bottom: '100px', left: '50%'}
    if (isMobile) {
      window.gameChatConfig.position.mobile = position;
      console.log('Mobile chat position updated:', position);
      
      // Direct DOM manipulation for immediate effect
      const chatContainer = document.getElementById('game-chat-container');
      if (chatContainer) {
        Object.keys(position).forEach(key => {
          chatContainer.style[key] = position[key];
        });
        
        // Ensure transform is applied for centering if left:50% is being used
        if (position.left === '50%') {
          chatContainer.style.transform = 'translateX(-50%)';
        }
      }
    } else {
      window.gameChatConfig.position.desktop = position;
      console.log('Desktop chat position updated:', position);
      
      // Direct DOM manipulation for immediate effect
      const chatContainer = document.getElementById('game-chat-container');
      if (chatContainer) {
        Object.keys(position).forEach(key => {
          chatContainer.style[key] = position[key];
        });
        
        // Ensure transform is applied for centering if left:50% is being used
        if (position.left === '50%') {
          chatContainer.style.transform = 'translateX(-50%)';
        }
      }
    }
  };

  // Function to resize chat
  window.resizeChat = (width, isMobile = false) => {
    if (isMobile) {
      if (width === 'auto' || width === 'fullWidth') {
        // Calculate width as window width minus margins (20px on each side)
        const viewportWidth = window.innerWidth;
        const fullWidthWithMargins = viewportWidth - 40; // 20px margin on each side
        
        window.gameChatConfig.size.width.mobile = fullWidthWithMargins;
        console.log('Mobile chat width updated to full width with margins:', fullWidthWithMargins);
        
        // Direct DOM manipulation for immediate effect
        const chatContainer = document.getElementById('game-chat-container');
        if (chatContainer) {
          chatContainer.style.width = `${fullWidthWithMargins}px`;
        }
        
        // Add resize listener to keep the width updated when screen size changes
        if (!window.chatResizeListenerAdded) {
          window.addEventListener('resize', () => {
            const newWidth = window.innerWidth - 40;
            const chatContainer = document.getElementById('game-chat-container');
            if (chatContainer && window.gameChatConfig.size.width.mobile === 'fullWidth') {
              chatContainer.style.width = `${newWidth}px`;
              console.log('Adjusted chat width on resize:', newWidth);
            }
          });
          window.chatResizeListenerAdded = true;
        }
        
        // Store that we're using a responsive width
        window.gameChatConfig.size.width.mobile = 'fullWidth';
      } else {
        // Use fixed width as before
        window.gameChatConfig.size.width.mobile = width;
        console.log('Mobile chat width updated to fixed width:', width);
        
        // Direct DOM manipulation for immediate effect
        const chatContainer = document.getElementById('game-chat-container');
        if (chatContainer) {
          chatContainer.style.width = `${width}px`;
        }
      }
    } else {
      window.gameChatConfig.size.width.desktop = width;
      console.log('Desktop chat width updated:', width);
      
      // Direct DOM manipulation for immediate effect
      const chatContainer = document.getElementById('game-chat-container');
      if (chatContainer) {
        chatContainer.style.width = `${width}px`;
      }
    }
  };

  // Add a convenience function to apply full width with margins on mobile
  window.setMobileFullWidth = () => {
    // Calculate width as window width minus margins (20px on each side)
    const viewportWidth = window.innerWidth;
    const fullWidthWithMargins = viewportWidth - 40; // 20px margin on each side
    
    // Set initial width value
    const chatContainer = document.getElementById('game-chat-container');
    if (chatContainer) {
      chatContainer.style.width = `${fullWidthWithMargins}px`;
      console.log('Set chat to full width with margins:', fullWidthWithMargins);
    }
    
    // Store the configuration 
    window.gameChatConfig.size.width.mobile = 'fullWidth';
    
    // Add resize listener (if not already added)
    if (!window.chatResizeListenerAdded) {
      window.addEventListener('resize', () => {
        const newWidth = window.innerWidth - 40;
        const chatContainer = document.getElementById('game-chat-container');
        if (chatContainer && window.gameChatConfig.size.width.mobile === 'fullWidth') {
          chatContainer.style.width = `${newWidth}px`;
          console.log('Adjusted chat width on resize:', newWidth);
        }
      });
      window.chatResizeListenerAdded = true;
    }
    
    // Position at the desired location
    window.positionChat({bottom: '180px', left: '50%'}, true);
    
    return fullWidthWithMargins;
  };
  
  // Initialize responsive width on load for mobile
  if (typeof window !== 'undefined' && window.innerWidth <= 768) {
    setTimeout(() => window.setMobileFullWidth(), 1000);
  }
}

// UI configuration for Helper Character with mobile-specific options
const helperUIConfig = {
  // Character position and size
  position: {
    desktop: [-5.6, 0, 15],  // [x, y, z] for desktop
    mobile: [-5.6, 0, 15]     // [x, y, z] for mobile (closer/more visible)
  },
  scale: {
    desktop: 0.14,          // Desktop scale
    mobile: 0.14            // Mobile scale (slightly smaller)
  },
  // Character box UI
  messageBox: {
    width: {
      desktop: 390,        // Desktop width in pixels
      mobile: 370          // Mobile width in pixels (smaller)
    },
    height: {
      desktop: 400,        // Desktop height in pixels
      mobile: 480          // Mobile height in pixels (fixed 3 to 300)
    },
    // Add 3D position property for the chatbox
    position3D: {
      desktop: [2.5, 14, 8],  // [x, y, z] for desktop chatbox position
      mobile: [-1.25, 13, 5]    // [x, y, z] for mobile chatbox position
    },
    position: {
      desktop: { top: '50%', left: '50%', transform: 'translate(-50%, -50%)' },
      mobile: { top: '50%', left: '50%', transform: 'translate(-50%, -50%)' },
      center: { top: '50%', left: '50%', transform: 'translate(-50%, -50%)' }
    },
    fontSize: {
      desktop: '14px',
      mobile: '13px'
    },
    zIndex: 1000,
  },
  // Badges for interactions
  badge: {
    size: {
      desktop: '11px',
      mobile: '10px'
    },
    position: {
      desktop: { x: 0, y: 18, z: 0 },
      mobile: { x: 0, y: 17.5, z: 1}
    },
    scale: {
      desktop: 0.6,  // Reduced by 35% (from 0.5 to 0.325)
      mobile: 0.6   // Same scale for mobile by default
    }
  },
  // Shadow configuration
  shadow: {
    normalColor: '#2a2a2a',  // Dark color when not near
    nearColor: '#22aa22',    // Green when near (matching ClothingShop)
    normalOpacity: 0.7,
    nearOpacity: 0.5
  }
};

// Add console helpers for adjusting the UI
console.log("=== Helper UI Configuration Guide ===");
console.log("Access via the browser console:");
console.log("");
console.log("Character Position:");
console.log("window.helperUIConfig.position.mobile = [x, y, z]");
console.log("");
console.log("Character Scale:");
console.log("window.helperUIConfig.scale.mobile = 0.15");
console.log("");
console.log("Message Box Width & Height:");
console.log("window.helperUIConfig.messageBox.width.mobile = 300");
console.log("window.helperUIConfig.messageBox.height.mobile = 300");
console.log("");
console.log("Chatbox 3D Position (key setting to adjust):");
console.log("window.helperUIConfig.messageBox.position3D.desktop = [0, 15, 5]");
console.log("window.helperUIConfig.messageBox.position3D.mobile = [0, 12, 5]");
console.log("");
console.log("Badge Scale:");
console.log("window.helperUIConfig.badge.scale.desktop = 0.325");
console.log("window.helperUIConfig.badge.scale.mobile = 0.325");
console.log("");
console.log("Shadow Color:");
console.log("window.helperUIConfig.shadow.nearColor = '#00AA00'");
console.log("");
console.log("=== Game Chat UI Configuration ===");
console.log("Direct Control Functions:");
console.log("window.forceHideChatUI(true)   // Force hide chat UI (most reliable)");
console.log("window.forceHideChatUI(false)  // Force show chat UI");
console.log("");
console.log("Special Interactions:");
console.log("window.startHelperInteraction()      // Hide chat during Helper interaction");
console.log("window.startClothingShopInteraction() // Hide chat during ClothingShop interaction");
console.log("window.startBarberShopInteraction()  // Hide chat during BarberShop interaction");
console.log("window.endCharacterInteraction()     // Show chat after interaction ends");
console.log("");
console.log("Standard Control:");
console.log("window.toggleChat(false)  // Hide chat UI");
console.log("window.toggleChat(true)   // Show chat UI");
console.log("");
console.log("Position Chat (Desktop):");
console.log("window.positionChat({bottom: '20px', left: '50%'})");
console.log("");
console.log("Position Chat (Mobile):");
console.log("window.positionChat({bottom: '180px', left: '50%'}, true)");
console.log("");
console.log("Resize Chat Width (Desktop):");
console.log("window.resizeChat(400)  // Width in pixels");
console.log("");
console.log("Resize Chat Width (Mobile):");
console.log("window.resizeChat(320, true)  // Fixed width in pixels");
console.log("window.resizeChat('fullWidth', true)  // Responsive width (window width - 40px margins)");
console.log("window.setMobileFullWidth()  // Quick setup for responsive mobile width + position");
console.log("");
console.log("Legacy Commands (may not work as expected):");
console.log("window.gameChatConfig.position.mobile = { bottom: '70px', left: '50%' }");
console.log("window.gameChatConfig.size.width.mobile = 300");
console.log("window.gameChatConfig.visible = false // Hide game chat");
console.log("window.gameChatConfig.visible = true  // Show game chat");
console.log("");
console.log("Hide Game Messaging UI in Shops:");
console.log("window.hideGameMessaging = true  // Hide chat in shops");
console.log("window.hideGameMessaging = false // Show chat in shops");
console.log("");
console.log("Hide/Show Joystick:");
console.log("window.hideJoystick = true  // Hide joystick");
console.log("window.hideJoystick = false // Show joystick");
console.log("================================");

// Make configuration accessible globally for real-time adjustments
if (typeof window !== 'undefined') {
  window.helperUIConfig = helperUIConfig;
  window.gameChatConfig = gameChatConfig; // Make game chat config available globally
}

// Function to hide chat when interacting with special characters
window.hideGameChatDuringInteraction = (interactionType) => {
  // Set the flag to hide the chat UI
  window.hideGameMessaging = true;
  console.log(`Chat UI hidden while interacting with: ${interactionType}`);
};

// Function to show chat after interaction ends
window.showGameChatAfterInteraction = () => {
  // Only restore chat if it wasn't force hidden
  if (!window.forceHideGameChat) {
    // Explicitly reset all flags that might prevent the chat from showing
    window.hideGameMessaging = false;
    
    // Make sure the config is also updated
    if (window.gameChatConfig) {
      window.gameChatConfig.visible = true;
    }
    
    console.log('Chat UI restored after interaction');
  }
};

// Helper functions for each interaction type
window.startHelperInteraction = () => {
  window.hideGameChatDuringInteraction('HelperCharacter');
};

window.startClothingShopInteraction = () => {
  window.hideGameChatDuringInteraction('ClothingShop');
};

window.startBarberShopInteraction = () => {
  window.hideGameChatDuringInteraction('BarberShop');
};

window.endCharacterInteraction = () => {
  window.showGameChatAfterInteraction();
};

const HelperCharacter = forwardRef((props, ref) => {
  const group = React.useRef()
  const [isNear, setIsNear] = useState(false)
  const [showChatbox, setShowChatbox] = useState(false)
  const [message, setMessage] = useState('')
  const [reply, setReply] = useState([])
  const chatContainerRef = useRef(null)
  const { scene, animations } = useGLTF('/AI_HELPER.glb')
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene])
  const { nodes, materials } = useGraph(clone)
  const { actions } = useAnimations(animations, group)
  const { camera } = useThree() // Access the camera

  // Add this line to detect mobile view
  const isMobile = useMediaQuery({ query: '(max-width: 768px)' });
  
  // For example, in your render function:
  // Use the appropriate scale based on device
  const scale = isMobile ? helperUIConfig.scale.mobile : helperUIConfig.scale.desktop;
  
  // Use the appropriate position based on device
  const position = isMobile ? helperUIConfig.position.mobile : helperUIConfig.position.desktop;
  
  // Later in your component
  // For the message box styling
  const messageBoxStyle = {
    width: isMobile ? helperUIConfig.messageBox.width.mobile : helperUIConfig.messageBox.width.desktop,
    fontSize: isMobile ? helperUIConfig.messageBox.fontSize.mobile : helperUIConfig.messageBox.fontSize.desktop,
    zIndex: helperUIConfig.messageBox.zIndex,
    // Remove position properties - handled by the 3D positioning now
  };
  
  // For the badge styling
  const badgeSize = isMobile ? helperUIConfig.badge.size.mobile : helperUIConfig.badge.size.desktop;
  const badgePosition = isMobile ? helperUIConfig.badge.position.mobile : helperUIConfig.badge.position.desktop;
  
  // Define a character shadow component
  const CharacterShadow = () => {
    return (
      <mesh 
        rotation={[-Math.PI / 2, 0, 0]} 
        position={[0, 0.01, 1]} 
        receiveShadow={false}
      >
        <circleGeometry args={[5, 64]} />
        <meshBasicMaterial 
          color={isNear ? helperUIConfig.shadow.nearColor : helperUIConfig.shadow.normalColor}
          transparent={true}
          opacity={isNear ? helperUIConfig.shadow.nearOpacity : helperUIConfig.shadow.normalOpacity}
          depthWrite={false}
        />
      </mesh>
    );
  };

  // Connect the forwarded ref to our group
  React.useImperativeHandle(ref, () => group.current)

  // Set up a state to track post-chat transition
  const [inPostChatTransition, setInPostChatTransition] = useState(false);

  // Store original rotation to return to after conversation ends
  const originalRotation = useRef([0, Math.PI / 4, 0]);
  
  // Create a ref for target rotation - moved outside useEffect
  const targetRotation = useRef(0);

  // Rotate helper to face camera when chatbox is opened
  useEffect(() => {
    if (!group.current) return;
    
    if (showChatbox) {
      // Save original rotation if not already saved
      if (!originalRotation.current) {
        originalRotation.current = [
          group.current.rotation.x,
          group.current.rotation.y,
          group.current.rotation.z
        ];
      }

      // Function to update target rotation based on camera position
      const updateTargetRotation = () => {
        if (!group.current || !camera) return;
        
        // Get positions
        const helperPos = new THREE.Vector3();
        group.current.getWorldPosition(helperPos);
        
        // Get camera position
        const cameraPos = new THREE.Vector3();
        camera.getWorldPosition(cameraPos);
        
        // Direction from helper to camera (only consider XZ plane)
        const direction = new THREE.Vector2(
          cameraPos.x - helperPos.x,
          cameraPos.z - helperPos.z
        );
        
        // Calculate target angle
        targetRotation.current = Math.atan2(direction.x, direction.y);
      };
      
      // Animation loop for smooth rotation
      const animateRotation = () => {
        if (!group.current) return;
        
        // Get current rotation and calculate the difference
        const currentRotation = group.current.rotation.y;
        let rotationDifference = targetRotation.current - currentRotation;
        
        // Handle rotation wrap-around (e.g., from 359° to 1°)
        if (rotationDifference > Math.PI) {
          rotationDifference -= Math.PI * 2;
        } else if (rotationDifference < -Math.PI) {
          rotationDifference += Math.PI * 2;
        }
        
        // Smoothly interpolate rotation
        if (Math.abs(rotationDifference) > 0.01) {
          group.current.rotation.y += rotationDifference * 0.1;
        }
      };
      
      // Update target rotation immediately and every 100ms
      updateTargetRotation();
      const targetUpdateInterval = setInterval(updateTargetRotation, 100);
      
      // Start animation loop using requestAnimationFrame for smooth rotation
      let animationFrameId;
      const animate = () => {
        animateRotation();
        animationFrameId = requestAnimationFrame(animate);
      };
      animate();
      
      // Clean up both the interval and animation frame
      return () => {
        clearInterval(targetUpdateInterval);
        cancelAnimationFrame(animationFrameId);
      };
    } else if (originalRotation.current) {
      // Smoothly return to original rotation when chat is closed
      const returnToOriginal = () => {
        if (!group.current) return;
        
        // Calculate difference between current and original rotation
        const currentRotation = group.current.rotation.y;
        const originalY = originalRotation.current[1];
        let rotationDifference = originalY - currentRotation;
        
        // Handle rotation wrap-around
        if (rotationDifference > Math.PI) {
          rotationDifference -= Math.PI * 2;
        } else if (rotationDifference < -Math.PI) {
          rotationDifference += Math.PI * 2;
        }
        
        // Smoothly transition back to original rotation
        if (Math.abs(rotationDifference) > 0.01) {
          group.current.rotation.y += rotationDifference * 0.1;
          requestAnimationFrame(returnToOriginal);
        } else {
          // Once we're close enough, set exact values
          group.current.rotation.x = originalRotation.current[0];
          group.current.rotation.y = originalRotation.current[1];
          group.current.rotation.z = originalRotation.current[2];
        }
      };
      
      // Start the return animation
      returnToOriginal();
    }
  }, [showChatbox, camera]);

  // Set global flag when chatbox state changes
  useEffect(() => {
    window.chatboxOpen = showChatbox;
    
    // If transitioning from open to closed, start transition period
    if (!showChatbox && !inPostChatTransition) {
      setInPostChatTransition(true);
      // Exit transition period after camera has had time to reposition
      setTimeout(() => {
        setInPostChatTransition(false);
      }, 1500); // 1.5 second transition time (increased from 1 second)
    }
    
    
    return () => {
      window.chatboxOpen = false;
    }
  }, [showChatbox, inPostChatTransition]);
  
  // Make the post-chat transition state available globally
  useEffect(() => {
    window.inChatTransition = inPostChatTransition;
  }, [inPostChatTransition]);

  // Set up the initial pose (Animation4) and animations
  useEffect(() => {
    if (!actions) return;
    
    // Log available animations for debugging
    console.log("Available animations:", Object.keys(actions));
    
    // Find Animation4 and Animation5
    const idleAnimation = actions['Animation4'] || Object.values(actions)[3]; // Fallback to 4th animation if not named
    const talkAnimation = actions['Animation5'] || Object.values(actions)[4]; // Fallback to 5th animation if not named
    
    // Set up animations with appropriate settings
    if (idleAnimation) {
      idleAnimation.reset();
      idleAnimation.setEffectiveTimeScale(1);
      idleAnimation.setLoop(THREE.LoopRepeat, Infinity);
      idleAnimation.clampWhenFinished = false;
      idleAnimation.play();
    }
    
    if (talkAnimation) {
      talkAnimation.reset();
      talkAnimation.setEffectiveTimeScale(1);
      talkAnimation.setLoop(THREE.LoopRepeat, Infinity);
      talkAnimation.clampWhenFinished = false;
      // Don't play it yet - we'll play it when needed
      talkAnimation.stop();
    }
    
    // Store animations in refs for later use
    window.helperAnimations = {
      idle: idleAnimation,
      talk: talkAnimation
    };
    
  }, [actions]);
  
  // Handle animations based on chatbox state and reply changes
  useEffect(() => {
    if (!window.helperAnimations?.idle || !window.helperAnimations?.talk) return;
    
    const { idle, talk } = window.helperAnimations;
    
    // Only trigger on chatbox close or open, not on every reply change
    // (The reply-based animation is now handled in handleSubmit)
    if (!showChatbox) {
      // When chatbox is closed, ensure we're in idle state
      
      // Stop any running animation transition
      if (window.animationTransitionTimeout) {
        clearTimeout(window.animationTransitionTimeout);
      }
      
      // Crossfade between animations
      talk.fadeOut(0.3);
      idle.reset();
      idle.fadeIn(0.3);
      idle.play();
    }
    
    // Cleanup
    return () => {
      if (window.animationTransitionTimeout) {
        clearTimeout(window.animationTransitionTimeout);
      }
    };
  }, [showChatbox]);

  // Simplified proximity detection without characterRef
  useEffect(() => {
    // Set a static value for isNear instead of checking proximity
    setIsNear(true);
    
    // For demonstration purposes, check if camera is near the helper
    if (camera) {
      const checkProximity = () => {
        if (!group.current) return;
        
        const helperPos = new THREE.Vector3();
        group.current.getWorldPosition(helperPos);
        
        const cameraPos = new THREE.Vector3();
        camera.getWorldPosition(cameraPos);
        
        const distance = cameraPos.distanceTo(helperPos);
        const newIsNear = distance < 15; // Larger radius for detection
        setIsNear(newIsNear);
        
        // If user walks away while chatbox is open, close it
        if (showChatbox && !newIsNear) {
          setShowChatbox(false);
          setMessage('');
          setReply([]);
        }
      };
      
      // Check proximity every 100ms
      const interval = setInterval(checkProximity, 100);
      return () => clearInterval(interval);
    }
  }, [camera, showChatbox]);
  
  // Set initial welcome message when chatbox opens
  useEffect(() => {
    if (showChatbox && reply.length === 0) {
      // Add welcome message when chatbox is opened for the first time
      setReply([
        { sender: 'ai', text: "Hi, I'm an AI assistant, how can I help?" }
      ])
    }
  }, [showChatbox, reply.length])
  
  // Auto-scroll to bottom when messages change
  useEffect(() => {
    if (chatContainerRef.current) {
      chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight
    }
  }, [reply])
  
  // Handle chat submission
  const handleSubmit = (e) => {
    e.preventDefault()
    if (message.trim()) {
      // Store user message and AI response
      const userMessage = message
      
      // Add user message immediately
      setReply(prev => [
        ...prev,
        { sender: 'user', text: userMessage }
      ])
      
      // Clear input field
      setMessage('')
      
      // Generate AI response based on user message
      let aiResponse = "Hi, I'm an AI assistant, how can I help?"
      
      // Simple response patterns for a more interactive feel
      const lowerMessage = userMessage.toLowerCase()
      if (lowerMessage.includes('hello') || lowerMessage.includes('hi')) {
        aiResponse = "Hello there! How can I assist you today?"
      } else if (lowerMessage.includes('how are you')) {
        aiResponse = "I'm doing well, thanks for asking! How can I help you?"
      } else if (lowerMessage.includes('help')) {
        aiResponse = "I'd be happy to help! What do you need assistance with?"
      } else if (lowerMessage.includes('thank')) {
        aiResponse = "You're welcome! Is there anything else you'd like to know?"
      } else if (lowerMessage.includes('bye') || lowerMessage.includes('goodbye')) {
        aiResponse = "Goodbye! Feel free to chat again if you need anything."
      }
      
      // Add AI response with a slight delay to simulate thinking
      setTimeout(() => {
        setReply(prev => [
          ...prev,
          { sender: 'ai', text: aiResponse }
        ])
        
        // Start talking animation - but first check if we have animations
        if (window.helperAnimations?.idle && window.helperAnimations?.talk) {
          const { idle, talk } = window.helperAnimations;
          
          console.log("Starting AI response animation");
          // Crossfade to talking animation
          idle.fadeOut(0.3);
          talk.reset();
          talk.fadeIn(0.3);
          talk.play();
          
          // Calculate duration based on message length
          // For better timing, count words rather than characters
          const wordCount = aiResponse.split(/\s+/).length;
          // Average speaking rate - approximately 2-3 words per second
          const speakingDuration = Math.max(2, Math.min(8, wordCount / 2.5));
          
          console.log(`AI response animation duration: ${speakingDuration}s (${wordCount} words)`);
          
          // After message "speaking" duration, transition back to idle
          if (window.animationTransitionTimeout) {
            clearTimeout(window.animationTransitionTimeout);
          }
          
          window.animationTransitionTimeout = setTimeout(() => {
            console.log("AI finished talking - returning to idle");
            talk.fadeOut(0.3);
            idle.reset();
            idle.fadeIn(0.3);
            idle.play();
          }, speakingDuration * 1000);
        }
      }, 500)
    }
  }

  // Function to safely open the chatbox
  const openChatbox = () => {
    console.log("Opening chatbox from shared function");
    setShowChatbox(true);
    
    // Use direct DOM manipulation to hide game chat immediately
    window.directlyHideChatUI(true);
    
    // Start helper interaction to hide game chat
    window.startHelperInteraction();
    console.log("Started helper interaction, hiding chat");
    
    // Ensure the global flags are updated immediately
    window.chatboxOpen = true;
    window.hideJoystick = true; // Hide joystick UI
  }
  
  // Function to safely close the chatbox
  const closeChatbox = () => {
    console.log("Closing chatbox from shared function");
    // First update state
    setShowChatbox(false);
    setMessage('');
    setReply([]);
    
    // Ensure the global flags are updated immediately
    window.chatboxOpen = false;
    window.hideJoystick = false; // Show joystick again
    
    // Make sure the hideGameMessaging flag is reset AFTER state updates
    // to ensure proper cleanup
    setTimeout(() => {
      // Use direct DOM manipulation to show game chat
      window.directlyHideChatUI(false);
      
      // End interaction to restore game chat AFTER all state is updated
      window.endCharacterInteraction();
      console.log("Released chat after helper interaction ended");
    }, 100);
    
    // Force camera transition to complete by manipulating camera config temporarily
    if (window.cameraConfig) {
      // Store original values
      const originalDistance = window.cameraConfig.distance;
      const originalTransitionSpeed = window.cameraConfig.helperFocus.transitionSpeed;
      const originalReturnSpeed = window.cameraConfig.returnSpeed;
      
      // Temporarily boost transition speeds for immediate effect - but not too fast
      window.cameraConfig.helperFocus.transitionSpeed = 5; // Reduced from 10 for smoother transition
      window.cameraConfig.returnSpeed = 0.25; // Reduced from 0.5 for smoother transition
      
      // Temporarily increase distance for more zoom out, but not excessively
      window.cameraConfig.distance = 11.0; // Slightly less than before (was 12.0)
      
      // Restore original values after transition completes
      setTimeout(() => {
        // First step: reduce boosted values gradually
        window.cameraConfig.helperFocus.transitionSpeed = originalTransitionSpeed * 1.5;
        window.cameraConfig.returnSpeed = originalReturnSpeed * 1.5;
        window.cameraConfig.distance = originalDistance * 1.1;
        
        // Final step: restore original values completely
        setTimeout(() => {
          window.cameraConfig.helperFocus.transitionSpeed = originalTransitionSpeed;
          window.cameraConfig.returnSpeed = originalReturnSpeed;
          window.cameraConfig.distance = originalDistance;
        }, 500);
      }, 500);
    }
  }

  return (
    <group 
      ref={group} 
      dispose={null} 
      scale={scale} 
      position={position} 
      rotation={[0, Math.PI / 4, 0]}
    >
      {/* Character shadow */}
      <CharacterShadow />
      
      {/* Badge above character - only show when not in chat mode */}
      {!showChatbox && (
      <Html
          position={[
            isMobile ? helperUIConfig.badge.position.mobile.x : helperUIConfig.badge.position.desktop.x,
            isMobile ? helperUIConfig.badge.position.mobile.y : helperUIConfig.badge.position.desktop.y,
            isMobile ? helperUIConfig.badge.position.mobile.z : helperUIConfig.badge.position.desktop.z
          ]}
        center
          wrapperClass="helper-badge-wrapper"
          distanceFactor={15}
          onClick={(e) => {
            console.log("HTML Badge wrapper clicked");
            e.stopPropagation();
            if (isNear) {
              console.log("HTML Badge wrapper: Opening chatbox...");
              openChatbox();
            }
          }}
        >
          <button
            className="helper-badge"
            onClick={(e) => {
              e.stopPropagation();
              e.preventDefault();
              console.log("Button Badge clicked directly");
              
              if (isNear) {
                console.log("Badge Button: Opening chatbox...");
                openChatbox();
              }
            }}
        style={{
              background: isNear ? helperUIConfig.shadow.nearColor : helperUIConfig.shadow.normalColor,
              padding: '10px 16px',
              borderRadius: '10px',
              color: 'white',
              fontSize: '16px',
              fontWeight: '600',
              whiteSpace: 'nowrap',
              userSelect: 'none',
              fontFamily: 'system-ui, -apple-system, sans-serif',
              boxShadow: '0 3px 6px rgba(0,0,0,0.3)',
              border: '2px solid white',
              transition: 'all 0.3s ease',
              transform: `scale(${isMobile ? helperUIConfig.badge.scale.mobile : helperUIConfig.badge.scale.desktop})`,
              cursor: isNear ? 'pointer' : 'default',
              pointerEvents: 'auto',
              zIndex: 1000,
              opacity: 0.9,
            }}
      >
        {isNear ? "Talk with me" : "AI Helper"}
          </button>
        </Html>
      )}
      
      {/* Stop talking button - only shown when in chat mode */}
      {showChatbox && (
        <Html
          position={[
            isMobile ? helperUIConfig.badge.position.mobile.x : helperUIConfig.badge.position.desktop.x,
            isMobile ? helperUIConfig.badge.position.mobile.y : helperUIConfig.badge.position.desktop.y,
            isMobile ? helperUIConfig.badge.position.mobile.z : helperUIConfig.badge.position.desktop.z
          ]}
          center
          wrapperClass="helper-badge-wrapper"
          distanceFactor={15}
        >
          <button
            className="helper-badge"
            onClick={(e) => {
              e.stopPropagation();
              console.log("Stop Talking button clicked");
              closeChatbox();
            }}
            style={{
              background: '#e74c3c',
              padding: '10px 16px',
              borderRadius: '10px',
              color: 'white',
              fontSize: '16px',
              fontWeight: '600',
              whiteSpace: 'nowrap',
              userSelect: 'none',
              fontFamily: 'system-ui, -apple-system, sans-serif',
              boxShadow: '0 3px 6px rgba(0,0,0,0.3)',
              border: '2px solid white',
              transform: `scale(${isMobile ? helperUIConfig.badge.scale.mobile : helperUIConfig.badge.scale.desktop})`,
              cursor: 'pointer',
              zIndex: 1010,
              opacity: 0.9,
            }}
          >
            Stop talking
          </button>
        </Html>
      )}
      
      {/* Chatbox popup */}
      {showChatbox && (
        <Html
          position={isMobile ? helperUIConfig.messageBox.position3D.mobile : helperUIConfig.messageBox.position3D.desktop}
          wrapperClass="helper-chatbox-wrapper"
          style={{
            width: messageBoxStyle.width,
            background: '#2a2a2a',
            borderRadius: '10px',
            boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
            padding: '16px',
            fontFamily: 'system-ui, -apple-system, sans-serif',
            pointerEvents: 'auto',
            color: 'white',
            zIndex: messageBoxStyle.zIndex,
          }}
        >
          <div style={{ position: 'relative' }} onClick={(e) => e.stopPropagation()}>
            <button
              onClick={(e) => {
                e.stopPropagation(); // Prevent event propagation
                console.log("X button: Closing chatbox...");
                closeChatbox();
              }}
              style={{
                position: 'absolute',
                top: '-5px',
                right: '-5px',
                background: '#e74c3c',
                color: 'white',
                border: 'none',
                borderRadius: '50%',
                width: '24px',
                height: '24px',
                cursor: 'pointer',
                fontSize: '14px',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                boxShadow: '0 2px 4px rgba(0,0,0,0.2)',
              }}
            >
              ✕
            </button>
            
            <div 
              ref={chatContainerRef}
              style={{ 
                height: isMobile ? `${helperUIConfig.messageBox.height.mobile}px` : `${helperUIConfig.messageBox.height.desktop}px`,
                marginBottom: '10px', 
                padding: '10px',
                background: '#333',
                borderRadius: '8px',
                overflowY: 'auto',
                display: 'flex',
                flexDirection: 'column'
              }}
            >
              {reply.length > 0 ? (
                reply.map((msg, index) => (
                  <div 
                    key={index}
                    style={{ 
                      background: msg.sender === 'ai' ? '#37BA7E' : '#555',
                      padding: '8px 12px', 
                      borderRadius: '12px',
                      marginBottom: '8px',
                      marginLeft: msg.sender === 'ai' ? '0' : 'auto',
                      marginRight: msg.sender === 'ai' ? 'auto' : '0',
                      maxWidth: '80%',
                      color: 'white',
                      alignSelf: msg.sender === 'ai' ? 'flex-start' : 'flex-end',
                      textAlign: msg.sender === 'ai' ? 'left' : 'right',
                      wordBreak: 'break-word'
                    }}
                  >
                    {msg.text}
                  </div>
                ))
              ) : (
                <div style={{
                  textAlign: 'center',
                  color: '#888',
                  marginTop: 'auto',
                  marginBottom: 'auto',
                  fontSize: messageBoxStyle.fontSize
                }}>
                  Type a message to start chatting
                </div>
              )}
            </div>
            
            <form onSubmit={handleSubmit} style={{ display: 'flex' }}>
              <input
                type="text"
                value={message}
                onChange={(e) => setMessage(e.target.value)}
                placeholder="Type a message..."
                style={{
                  flex: 1,
                  padding: '8px 12px',
                  borderRadius: '20px',
                  border: '1px solid #444',
                  outline: 'none',
                  background: '#333',
                  color: 'white',
                }}
              />
              <button
                type="submit"
                style={{
                  background: '#37BA7E',
                  color: 'white',
                  border: 'none',
                  borderRadius: '20px',
                  padding: '8px 16px',
                  marginLeft: '8px',
                  cursor: 'pointer',
                  boxShadow: '0 2px 4px rgba(0,0,0,0.2)',
                }}
              >
                Send
              </button>
            </form>
          </div>
      </Html>
      )}
      
      {/* Character model */}
      <group name="Main" onClick={(e) => {
        console.log("Character model clicked, chatbox state:", showChatbox);
        if (isNear && !showChatbox) {
          // Only open the chatbox if it's not already open
          console.log("Character model: Opening chatbox...");
          openChatbox();
        }
      }}>
        {/* Invisible clickable area around character to make clicking easier */}
        <mesh 
          visible={false} 
          position={[0, 10, 0]}
          onClick={(e) => {
            console.log("Invisible click area triggered");
            e.stopPropagation();
            if (isNear && !showChatbox) {
              console.log("Invisible area: Opening chatbox...");
              openChatbox();
            }
          }}
        >
          <boxGeometry args={[15, 20, 15]} />
          <meshBasicMaterial transparent opacity={0} />
        </mesh>
        
        <group name="James_SoftwareEngineer_rig">
          <skinnedMesh
            name="Headphones"
            geometry={nodes.Headphones.geometry}
            material={materials.MAT_Headphone}
            skeleton={nodes.Headphones.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="James_5FingerHandArms001"
            geometry={nodes.James_5FingerHandArms001.geometry}
            material={materials.skin_Baked}
            skeleton={nodes.James_5FingerHandArms001.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="james_body_geo002"
            geometry={nodes.james_body_geo002.geometry}
            material={materials.skin_Baked}
            skeleton={nodes.james_body_geo002.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="james_cap001"
            geometry={nodes.james_cap001.geometry}
            material={materials.james_cap_Baked}
            skeleton={nodes.james_cap001.skeleton}
            castShadow
            receiveShadow
            material-color={isNear ? helperUIConfig.shadow.nearColor : helperUIConfig.shadow.normalColor}
          />
          <skinnedMesh
            name="james_facial_hair"
            geometry={nodes.james_facial_hair.geometry}
            material={materials['Facial hair']}
            skeleton={nodes.james_facial_hair.skeleton}
            castShadow
            receiveShadow
          />
          <group name="james_hair_geo002">
            <skinnedMesh
              name="james_hair_geo002_1"
              geometry={nodes.james_hair_geo002_1.geometry}
              material={materials.James_hairbase}
              skeleton={nodes.james_hair_geo002_1.skeleton}
              castShadow
              receiveShadow
            />
            <skinnedMesh
              name="james_hair_geo002_2"
              geometry={nodes.james_hair_geo002_2.geometry}
              material={materials.Hair}
              skeleton={nodes.james_hair_geo002_2.skeleton}
              castShadow
              receiveShadow
            />
          </group>
          <skinnedMesh
            name="james_lf_eye_geo001"
            geometry={nodes.james_lf_eye_geo001.geometry}
            material={materials['James_eyes.001']}
            skeleton={nodes.james_lf_eye_geo001.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="james_lowerteeth_geo001"
            geometry={nodes.james_lowerteeth_geo001.geometry}
            material={materials['James_Mouth.001']}
            skeleton={nodes.james_lowerteeth_geo001.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="james_pants_geo001"
            geometry={nodes.james_pants_geo001.geometry}
            material={materials['james_pants_geo.003_Baked']}
            skeleton={nodes.james_pants_geo001.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="james_rt_eyebrow_geo001"
            geometry={nodes.james_rt_eyebrow_geo001.geometry}
            material={materials.James_hairbase}
            skeleton={nodes.james_rt_eyebrow_geo001.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="james_shirt_geo"
            geometry={nodes.james_shirt_geo.geometry}
            material={materials['James_Shirt.001']}
            skeleton={nodes.james_shirt_geo.skeleton}
            castShadow
            receiveShadow
            material-color={isNear ? helperUIConfig.shadow.nearColor : helperUIConfig.shadow.normalColor}
          />
          <skinnedMesh
            name="james_Tongue"
            geometry={nodes.james_Tongue.geometry}
            material={materials['James_Mouth.001']}
            skeleton={nodes.james_Tongue.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="james_upperteeth_geo"
            geometry={nodes.james_upperteeth_geo.geometry}
            material={materials['James_Mouth.001']}
            skeleton={nodes.james_upperteeth_geo.skeleton}
            castShadow
            receiveShadow
          />
          <skinnedMesh
            name="james_vans_geo001"
            geometry={nodes.james_vans_geo001.geometry}
            material={materials.james_vans_geo_Baked}
            skeleton={nodes.james_vans_geo001.skeleton}
            castShadow
            receiveShadow
          />
          <primitive object={nodes.Bone} />
          <primitive object={nodes.HeadphoneRoot} />
          <primitive object={nodes.MacbookRoot} />
          <primitive object={nodes.rootx} />
          <primitive object={nodes.footl} />
          <primitive object={nodes.thigh_twistl} />
          <primitive object={nodes.footr} />
          <primitive object={nodes.thigh_twistr} />
          <primitive object={nodes.spine_01x} />
          <primitive object={nodes.spine_02x} />
          <primitive object={nodes.neckx} />
          <primitive object={nodes.shoulderr} />
          <primitive object={nodes.c_arm_twist_offsetr} />
          <primitive object={nodes.arm_stretchr} />
          <primitive object={nodes.shoulderl} />
          <primitive object={nodes.c_arm_twist_offsetl} />
          <primitive object={nodes.arm_stretchl} />
          <primitive object={nodes.spine_03x} />
          <primitive object={nodes.headx} />
          <primitive object={nodes.leg_stretchl} />
          <primitive object={nodes.leg_stretchr} />
          <primitive object={nodes.forearm_stretchl} />
          <primitive object={nodes.forearm_stretchr} />
          <primitive object={nodes.handl} />
          <primitive object={nodes.handr} />
        </group>
      </group>
    </group>
  )
})

export default HelperCharacter

useGLTF.preload('/AI_HELPER.glb')
